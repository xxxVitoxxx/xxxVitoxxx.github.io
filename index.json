[{"categories":["instagram"],"content":"因 Meta Develop 開發政策，強制所有的用戶端 OAuth 都要使用 https 的 URL 才能被 Meta 認定為有效的 OAuth 重新導向 URL ，這會導致我們在地端測試時，會需要 https 的 URL 供我們做測試，這邊我們使用 ngrok 來產生一組 https 的 URL ，並帶著各位如何在地端使用 ngrok 來測試 instagram basic api ","date":"2022-08-09","objectID":"/instagram-basic/:0:0","tags":["instagram"],"title":"testing instagram basic api on localhost","uri":"/instagram-basic/"},{"categories":["instagram"],"content":"建立 instagram 的應用程式 ","date":"2022-08-09","objectID":"/instagram-basic/:1:0","tags":["instagram"],"title":"testing instagram basic api on localhost","uri":"/instagram-basic/"},{"categories":["instagram"],"content":"在 Meta 開發人員工具創建應用程式 到 Meta for Developers 建立應用程式 再來需要選擇應用程式的類型及填寫名稱，這邊需要注意類型的選擇會導致該應用程式可使用的產品、權限及功能，詳情可以參考官方文件 點選 instagram 基本顯示的設定 在 instagram 基本顯示 \u003e 基本顯示 中建立新的應用程式 ","date":"2022-08-09","objectID":"/instagram-basic/:1:1","tags":["instagram"],"title":"testing instagram basic api on localhost","uri":"/instagram-basic/"},{"categories":["instagram"],"content":"新增 instagram 測試人員 完成上面的步驟後，點選左邊選項中的 角色 \u003e instagram 測試人員的按鈕，輸入你要用來測試的 instagram 帳號 這時登入網頁版的 instagram ，在 設定 \u003e 應用程式和網站 \u003e 測試員邀請 ，會發現應用程式的邀請確認，點選接受就成功成為應用程式的測試人員 ","date":"2022-08-09","objectID":"/instagram-basic/:1:2","tags":["instagram"],"title":"testing instagram basic api on localhost","uri":"/instagram-basic/"},{"categories":["instagram"],"content":"建立一個 web 服務 這邊以 golang 搭建一個簡單的網頁並把服務放在 80 port package main import ( \"fmt\" \"log\" \"net/http\" ) func main() { http.HandleFunc(\"/ping\", func(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, \"pong\") }) log.Fatal(http.ListenAndServe(\":80\", nil)) } 把服務起起來並確認頁面有正常顯示，以上面範例，在瀏覽器 載入 localhost:80/ping 會出現以下圖例 ","date":"2022-08-09","objectID":"/instagram-basic/:2:0","tags":["instagram"],"title":"testing instagram basic api on localhost","uri":"/instagram-basic/"},{"categories":["instagram"],"content":"設定 ngrok ","date":"2022-08-09","objectID":"/instagram-basic/:3:0","tags":["instagram"],"title":"testing instagram basic api on localhost","uri":"/instagram-basic/"},{"categories":["instagram"],"content":"安裝 ngrok 先到 ngrok 官網 下載對應的版本並註冊登入會員，初次安裝需先驗證 ngrok 的 agent，到 Your Authtoken 執行 Command Line 的指令，會將 ngrok 的 Authtoken 保存在你的電腦，授於 agent 使用 ngrok 所有功能的權限 完成後執行 $ ngrok http {port} ，就可以將 localhost:{port} 的服務對外開放，因為我服務使用 80 port 的關係，所以我要執行 $ ngrok http 80 ，接著會看到以下圖片的樣子，就代表成功將地端的 80 port 對外開放，而紅色框框的 https 網址為你地端服務對外的網址，這時其他人就可以透過該網址連到你的網頁 ","date":"2022-08-09","objectID":"/instagram-basic/:3:1","tags":["instagram"],"title":"testing instagram basic api on localhost","uri":"/instagram-basic/"},{"categories":["instagram"],"content":"設定應用程式 回到 Meta for Developers 左邊選項的 instagram 基本顯示 \u003e 基本顯示 去設定 用戶端 OAuth 設定、取消授權、資料刪除要求，在圖中的三個欄位填入 ngrok 產生的 https 網址 ","date":"2022-08-09","objectID":"/instagram-basic/:3:2","tags":["instagram"],"title":"testing instagram basic api on localhost","uri":"/instagram-basic/"},{"categories":["instagram"],"content":"取得 instagram basic api 的 token ","date":"2022-08-09","objectID":"/instagram-basic/:4:0","tags":["instagram"],"title":"testing instagram basic api on localhost","uri":"/instagram-basic/"},{"categories":["instagram"],"content":"驗證測試人員 建構授權的視窗網址，{app-id} 為 instagram 基本顯示 \u003e 基本顯示 \u003e instagram 應用程式編號， {redirect-uri} 為有效的 OAuth 重新導向 URI的網址（網址必須完全相同） https://api.instagram.com/oauth/authorize ?client_id={app-id} \u0026redirect_uri={redirect-uri} \u0026scope=user_profile,user_media \u0026response_type=code 以我們剛剛產生的 https 網址為例 https://api.instagram.com/oauth/authorize ?client_id=135421602932815 \u0026redirect_uri=https://6e02-220-135-89-54.jp.ngrok.io/ping \u0026scope=user_profile,user_media \u0026response_type=code 在瀏覽器載入網址後，會出現應用程式要求權限的說明 點選允許後，會跳轉到你在應用程式設定的重新導向 URI的頁面，這時請觀察該網頁的網址 網址中的 code 到 #_ 之間為測試人員的授權碼 https://6e02-220-135-89-54.jp.ngrok.io/ping?code=AQAODGH_DePavKuPRK0UKy5nMnSBYG_EEjOcodAUC5Q-wVS0uP5SDjFNgNWdw2a4plybIndmH0CuPKvx5k-IDNlVh4sX2qjao1LKGRykYNvpn_6gTtYWYPDrcJR0Lt5JrWHdo5Nj70cBg6VMDeW-vyzEAXzgnfgUTg3FeOfdJ2vlBenmCsMqwCrOS2SSQzMLEGK1B7osZz7W8ckAGkiyYZUGTOTlIDDuy4UOpLJ_PJd_4g#_ ","date":"2022-08-09","objectID":"/instagram-basic/:4:1","tags":["instagram"],"title":"testing instagram basic api on localhost","uri":"/instagram-basic/"},{"categories":["instagram"],"content":"將授權碼換成 token 將 {app-id} 、 {app-secret} 、 {redirect-uri} 、 {code} 換成你的 instagram 應用程式編號、 instagram 應用程式密鑰 、重新導向 URI 、授權碼，並輸入指令傳送請求 curl -X POST https://api.instagram.com/oauth/access_token \\ -F client_id={app-id} \\ -F client_secret={app-secret} \\ -F grant_type=authorization_code \\ -F redirect_uri={redirect-uri} \\ -F code={code} 成功時，會回傳以下 json 格式 { \"access_token\": \"IGQVJV...\", \"user_id\": 178414005245354752 } 例如： 這時候就可以用 access_token 和 user_id 去串接 instagram basic api 了 ","date":"2022-08-09","objectID":"/instagram-basic/:4:2","tags":["instagram"],"title":"testing instagram basic api on localhost","uri":"/instagram-basic/"},{"categories":["instagram"],"content":"Reference Meta for Developers 產品開發 | 如何在Localhost實作與測試FB Login SDK功能 ","date":"2022-08-09","objectID":"/instagram-basic/:5:0","tags":["instagram"],"title":"testing instagram basic api on localhost","uri":"/instagram-basic/"},{"categories":["golang"],"content":"Go 的標準函式庫可以很容易的對 JSON 資料進行編、解碼的工作。 ","date":"2022-06-09","objectID":"/golang-json/:0:0","tags":["golang","json"],"title":"用 golang 處理 json 資料","uri":"/golang-json/"},{"categories":["golang"],"content":"json 資料轉換 ","date":"2022-06-09","objectID":"/golang-json/:1:0","tags":["golang","json"],"title":"用 golang 處理 json 資料","uri":"/golang-json/"},{"categories":["golang"],"content":"struct 在處理 struct 與 json 資料轉換時，只要 struct 內元素的名稱字首是大寫，就可以轉換成 json struct 轉換成 json json 的 key 會跟 struct 元素名稱一樣 type Person struct { Name string Age int } func main() { p := Person{ Name: \"vito\", Age: 11, } b, err := json.Marshal(p) if err != nil { fmt.Println(\"err: \", err) } fmt.Println(string(b)) // output: {\"Name\":\"vito\",\"Age\":11} } json 轉換成 struct 沒有加 struct tag 的情況下不管大小寫，只要字母是一樣即可將 json 轉換成 struct type Person struct { Personname string Age int } func main() { j := []byte(`{ \"personName\":\"vito\", \"age\":11 }`) p := Person{} if err := json.Unmarshal(j, \u0026p); err != nil { fmt.Println(\"err: \", err) } fmt.Println(p) // output: {vito 11} } ","date":"2022-06-09","objectID":"/golang-json/:1:1","tags":["golang","json"],"title":"用 golang 處理 json 資料","uri":"/golang-json/"},{"categories":["golang"],"content":"map map 轉換成 json func main() { m := map[string]interface{}{ \"name\": \"vito\", \"age\": 11, } b, err := json.Marshal(m) if err != nil { fmt.Println(\"err: \", err) } fmt.Println(string(b)) // output: {\"age\":11,\"name\":\"vito\"} } json 轉換成 map func main() { j := []byte(`{ \"name\":\"vito\", \"age\":11 }`) var m map[string]interface{} if err := json.Unmarshal(j, \u0026m); err != nil { fmt.Println(\"err: \", err) } fmt.Println(m) // output: map[age:11 name:vito] } ","date":"2022-06-09","objectID":"/golang-json/:1:2","tags":["golang","json"],"title":"用 golang 處理 json 資料","uri":"/golang-json/"},{"categories":["golang"],"content":"struct tag 可以看到上面 struct 轉成 json 的範例，轉換後的 key 都是大寫，如果今天你想要 key 是小寫的該怎麼辦呢？golang 提供了 struct tag 來實現 type Person struct { Name string `json:\"name\"` Age int `json:\"age\"` } func main() { p := Person{ Name: \"vito\", Age: 11, } b, err := json.Marshal(p) if err != nil { fmt.Println(\"err: \", err) } fmt.Println(string(b)) // output: {\"name\":\"vito\",\"age\":11} } 也可以透過 json tag 定義 key 值 type Person struct { Name string `json:\"person_name\"` Age int `json:\"person_age\"` } func main() { p := Person{ Name: \"vito\", Age: 11, } b, err := json.Marshal(p) if err != nil { fmt.Println(\"err: \", err) } fmt.Println(string(b)) // output: {\"person_name\":\"vito\",\"person_age\":11} } ","date":"2022-06-09","objectID":"/golang-json/:2:0","tags":["golang","json"],"title":"用 golang 處理 json 資料","uri":"/golang-json/"},{"categories":["golang"],"content":"omitempty 忽略空值 當結構體元素是默認值時，想要忽略它，可以使用 omitempty type Person struct { Name string `json:\"name,omitempty\"` Age int `json:\"age,omitempty\"` Address string `json:\"address,omitempty\"` } func main() { p := Person{ Name: \"vito\", Age: 11, } b, err := json.Marshal(p) if err != nil { fmt.Println(\"err: \", err) } fmt.Println(string(b)) // {\"name\":\"vito\",\"age\":11} // 當 Address 為默認值 \"\" 時，會忽略該元素 } 忽略 struct 當想忽略 Person 中的 School 時，則 School 必須是 pointer type Person struct { Name string `json:\"name,omitempty\"` Age int `json:\"age,omitempty\"` Address string `json:\"address,omitempty\"` // 若 School 不是 pointer ，就算加 omitempty 也無法忽略它 School *School `json:\"school,omitempty\"` } type School struct { Name string `json:\"name\"` Address string `json:\"address\"` } func main() { p := Person{ Name: \"vito\", Age: 11, } b, err := json.Marshal(p) if err != nil { fmt.Println(\"err: \", err) } fmt.Println(string(b)) // {\"name\":\"vito\",\"age\":11} } ","date":"2022-06-09","objectID":"/golang-json/:2:1","tags":["golang","json"],"title":"用 golang 處理 json 資料","uri":"/golang-json/"},{"categories":["golang"],"content":"string 轉換成 json 時，將型態轉為字串 type Person struct { Name string `json:\"name\"` Age int `json:\"age,string\"` } func main() { p := Person{ Name: \"vito\", Age: 11, } b, err := json.Marshal(p) if err != nil { fmt.Println(\"err: \", err) } fmt.Println(string(b)) // age 的值被轉為文字型態 // output: {\"name\":\"vito\",\"age\":\"11\"} } json 轉換 struct 將 json 格式的 age 的值（type: string） 轉換成 struct 時，原先 age 的型態會被轉成 int type Person struct { Name string `json:\"name\"` Age int `json:\"age,string\"` } func main() { // 原始的 json 資料， age 的值是文字型態的 11 j := []byte(`{ \"name\":\"vito\", \"age\":\"11\" }`) var p Person if err := json.Unmarshal(j, \u0026p); err != nil { fmt.Println(\"err: \", err) } fmt.Println(p) // output: {vito 11} fmt.Printf(\"%T\\n\", p.Age) // 轉換成 struct 後，原先文字型態的 11 變成 int 型態的 11 // output: int } 當要轉換成 struct 時，如果型態有錯誤，會回傳錯誤訊息，但還是會成功轉換成 struct ，只是型態有問題的元素的值會是默認值，而不是你的資料 type Person struct { Name string `json:\"name\"` Age int `json:\"age,string\"` } func main() { j := []byte(`{ \"name\":\"vito\", \"age\":\"11.1\" }`) var p Person if err := json.Unmarshal(j, \u0026p); err != nil { // 預計 json age 的值會變轉成 int ，但 json age 的值轉換後是 float ，所以出現錯誤 fmt.Println(\"err: \", err) // err: json: cannot unmarshal number 11.1 into Go struct field Person.age of type int } fmt.Println(p) // output: {vito 0} } ","date":"2022-06-09","objectID":"/golang-json/:2:2","tags":["golang","json"],"title":"用 golang 處理 json 資料","uri":"/golang-json/"},{"categories":["golang"],"content":"- 不管是否有資料想忽略元素可以用 - type Person struct { Name string `json:\"name\"` Age int `json:\"-\"` } func main() { p := Person{ Name: \"vito\", Age: 11, } b, err := json.Marshal(p) if err != nil { fmt.Println(\"err: \", err) } fmt.Println(string(b)) // output: {\"name\":\"vito\"} } 若只是想讓 json 的 key 是 - 時，只需要再加上 , type Person struct { Name string `json:\"name\"` Age int `json:\"-,\"` } func main() { p := Person{ Name: \"vito\", Age: 11, } b, err := json.Marshal(p) if err != nil { fmt.Println(\"err: \", err) } fmt.Println(string(b)) // output: {\"name\":\"vito\",\"-\":11} } ","date":"2022-06-09","objectID":"/golang-json/:2:3","tags":["golang","json"],"title":"用 golang 處理 json 資料","uri":"/golang-json/"},{"categories":["heroku"],"content":"軟體 pgAdmin Heroku PostgreSQL project ","date":"2021-10-05","objectID":"/operate-heroku-pg-using-pgadmin/:1:0","tags":["heroku","postgres"],"title":"透過 pgAdmin 操作 Heroku PostgreSQL Database","uri":"/operate-heroku-pg-using-pgadmin/"},{"categories":["heroku"],"content":"建立 postgres 登入Heroku，進到有Postgre專案的Resource，點擊Heroku Postgres 點選settings，我們需要 ‘Host’、‘Database’、‘User’、‘Port’、‘Password’ 的資訊 ","date":"2021-10-05","objectID":"/operate-heroku-pg-using-pgadmin/:2:0","tags":["heroku","postgres"],"title":"透過 pgAdmin 操作 Heroku PostgreSQL Database","uri":"/operate-heroku-pg-using-pgadmin/"},{"categories":["heroku"],"content":"建立與Heroku PostgreSQL資料庫的連結設定 開啟pgAdmin，在左上角的Servers點擊右鍵 →Create →Server… 在General標簽頁中，Name 欄位輸入可識別的名稱 在Connection標簽頁中 Host name/address 對應 Heroku Postgres的Host Port 對應 Heroku Postgres的Port Maintenance database 對應 Heroku Postgres的Database Username 對應 Heroku Postgres的User Password 對應 Heroku Postgres的Password Save password 勾選起來 在SSL標簽頁中，SSLmode 選擇Allow 關於其他選項可參考文件 在Advanced標簽頁中 DB restriction對應 Heroku Postgres的Database 點擊下方 Save存儲 存儲後打開的畫面可以看到在Heroku PostgreSQL的所有資料表都在Tables標籤下 ","date":"2021-10-05","objectID":"/operate-heroku-pg-using-pgadmin/:3:0","tags":["heroku","postgres"],"title":"透過 pgAdmin 操作 Heroku PostgreSQL Database","uri":"/operate-heroku-pg-using-pgadmin/"},{"categories":["heroku"],"content":"利用SQL語法來查詢資料庫的資料 在左邊的框框點擊右鍵選擇Query Tool 輸入SQL語法點擊右上方的三角形圖案執行命令 ","date":"2021-10-05","objectID":"/operate-heroku-pg-using-pgadmin/:4:0","tags":["heroku","postgres"],"title":"透過 pgAdmin 操作 Heroku PostgreSQL Database","uri":"/operate-heroku-pg-using-pgadmin/"},{"categories":["git"],"content":"建立 ssh key 和 git clone 、 git push 教學 GitHub 提供了兩種連線方式，分別是https與ssh，兩者最大的差別在於ssh可以立刻上傳，不需要輸入密碼，且安全性高。 ","date":"2021-05-17","objectID":"/git-clone-ssh-key/:0:0","tags":["ssh key"],"title":"Git Clone With SSH Key","uri":"/git-clone-ssh-key/"},{"categories":["git"],"content":"如何透過ssh連結GitHub 第一步：依作業系統下載對應的Git(本示範系統是macos) (或透過Homebrew download: $ brew install git) 第二步：產生金鑰 $ ssh-keygen -t rsa -b 4096 -C ' your id ' 用ssh-keygen建立金鑰 系統會請你輸入通行碼(若沒輸入直接回車，之後clone就不用輸入密碼) 再輸入一次通行碼後會顯示ssh的公鑰及私鑰路徑檔名 第三步： 將id_rsa.pub(公鑰)的內容新增到GitHub的Settings的SSH keys (公鑰的內容) $ cat ./.ssh/id_rsa.pub 點擊Add就大功告成！！！ ","date":"2021-05-17","objectID":"/git-clone-ssh-key/:1:0","tags":["ssh key"],"title":"Git Clone With SSH Key","uri":"/git-clone-ssh-key/"},{"categories":["git"],"content":"clone 第一步：先在終端機進到你要建立專案的地方。 $ cd 要建立專案的地方 第二步：clone 專案到本機 $ get clone '專案ssh網址' 第三部：輸入通行碼(若當初有設定的話) 下圖表示成功將專案裡的檔案clone到主機 clone下來的資料夾名稱會是你的GitHub的repository名稱 ","date":"2021-05-17","objectID":"/git-clone-ssh-key/:2:0","tags":["ssh key"],"title":"Git Clone With SSH Key","uri":"/git-clone-ssh-key/"},{"categories":["git"],"content":"push 第一步：示範新增一個名為README.md的檔案 並將新檔案丟到專案(xxxVitoxxx.github.io)的資料夾裡，並cd到專案的資料夾 第二步：確認專案的資料夾做了哪些更動 $ git status (紅色字體代表有更改過的檔案) 第三步：將新增的檔案加到Git版本控管 $ git add . (注意！！！這邊只是將專案資料夾的所有檔案加到Git工作目錄的索引中，尚未加到Git版本庫)。 可以再輸入一次 $ git status 確認專案資料夾的檔案是否已成功更新(綠色字體代表成功更新檔案) 第四步：為修改記錄命名一個名稱 $ git commit -m \"commit message\" 這邊將第一次修改記錄命名為’first commit' $ git log 可以查看該專案的修改紀錄 第五步： $ git push 將剛剛新增的檔案推到GitHub上 ","date":"2021-05-17","objectID":"/git-clone-ssh-key/:3:0","tags":["ssh key"],"title":"Git Clone With SSH Key","uri":"/git-clone-ssh-key/"},{"categories":null,"content":"About","date":"2019-08-02","objectID":"/about/","tags":null,"title":"About","uri":"/about/"}]