[{"categories":["data structure"],"content":"stack 是一種線性的資料結構，其新增資料或刪除資料都在同一端，這意味著，若你想刪除第一筆資料，就得先從最後一筆資料開始依序刪除。 遵循後進先出（LIFO, Last-in-First-out）或先進後出（FILO, First-in-Last-out）原則，像疊盤子，假設一次只能拿一個盤子，若你想疊盤子，就只能疊在最上面;若想拿到最下面的盤子，就得先從最上面的盤子開始一個一個拿走。 因 stack 特性，需實作以下幾種基本操作： Push: 新增資料到 stack 的頂端（top） Pop: 移除 stack 中頂端（top）的資料 Peek: 取得頂端（top）的資料 並實作以下幾種操作輔助： IsEmpty: 檢查 stack 是否為空 IsFull: 檢查 stack 是否被填滿（當 stack 是有長度限制才需要實作） Size: stack 大小 Print: 印出 stack 資料 Push operation 這是在 stack 實現 Push 操作的圖形說明，它展示了當資料被新增到 stack 時， stack 如何由左至右增長。 Pop operation 這是在 stack 實現 Pop 操作的圖形說明，它展示了當資料從 stack 被移除時， stack 如何由左至右減少。 ","date":"2022-11-29","objectID":"/stack/:0:0","tags":["stack","data structure"],"title":"Stack","uri":"/stack/"},{"categories":["data structure"],"content":"Implement of the stack in golang 可以用 slice 與 linked list 實作 stack，這邊用 slice 示範如何實作。 ","date":"2022-11-29","objectID":"/stack/:1:0","tags":["stack","data structure"],"title":"Stack","uri":"/stack/"},{"categories":["data structure"],"content":"slice based stack Declaring stack type StackSlice struct { top int capacity int stack []int } func NewStackSlice(capacity int) *StackSlice { return \u0026StackSlice{ top: -1, capacity: capacity, stack: make([]int, 0, capacity), } } stack 結構有以下三種屬性： top: stack 中最後一筆資料的位置（當沒有資料時; top 為 -1） capacity: stack 的大小 stack: int 屬性的 slice Implementing a IsEmpty operation 檢查 stack 是否有資料。 func (s *StackSlice) IsEmpty() bool { return s.top == -1 } Implementing a IsFull operation 檢查 stack 是否還有空間可以存放資料。 func (s *StackSlice) IsFull() bool { return s.top+1 == s.capacity } Implementing a Size operation 回傳 stack 大小。 func (s *StackSlice) Size() int { return s.top + 1 } Implementing a Peek operation 回傳 stack 最後一筆資料。 func (s *StackSlice) Peek() (int, error) { if s.IsEmpty() { return 0, errors.New(\"stack underflow\") } return s.stack[s.top], nil } Implementing a Print operation 印出 stack 中所有資料。 func (s *StackSlice) Print() { for i := 0; i \u003c= s.top; i++ { fmt.Printf(\"%d \", s.stack[i]) } fmt.Println() } Implementing a Push operation 新增資料到 stack func (s *StackSlice) Push(data int) error { if s.IsFull() { return errors.New(\"stack overflow\") } s.top++ s.stack[s.top] = data return nil } Push 實現的方法如下所述： 第 2 行： 先檢查 stack 是否還有空間可以存放資料。 第 6 行： 調整 top 位置 第 7 行： 將資料指定到 top 位置 Implementing a Pop operation 從 stack 移除資料 func (s *StackSlice) Pop() error { if s.IsEmpty() { return errors.New(\"stack underflow\") } s.stack = s.stack[:s.top] s.top-- return nil } Pop 實現的方法如下所述： 第 2 行： 檢查 stack 是否有資料 第 6 行： 從 slice 移除 top 的資料 第 7 行： 調整 top 位置 ","date":"2022-11-29","objectID":"/stack/:1:1","tags":["stack","data structure"],"title":"Stack","uri":"/stack/"},{"categories":["data structure"],"content":"application of stack in data structure 這邊舉例幾個 stack 的應用 Parentheses Checking Expression Evaluation and Conversion Backtracking String Reversal Towers of Hanoi ","date":"2022-11-29","objectID":"/stack/:2:0","tags":["stack","data structure"],"title":"Stack","uri":"/stack/"},{"categories":["data structure"],"content":"1. Parentheses Checking 檢查 () 、 [] 、 {} 括號在是否有效，同時檢查左右括號是否是平衡的。 例如 [(){}] 是平衡的，而 {[}] 是不平衡的。 ","date":"2022-11-29","objectID":"/stack/:2:1","tags":["stack","data structure"],"title":"Stack","uri":"/stack/"},{"categories":["data structure"],"content":"2. Expression Evaluation and Conversion 表達式的評估（計算）與轉換，表達式有以下三種型態： Prefix Expression（前輟表達式） 又稱波蘭表達式，其特點是沒有括號且運算符號在數字前面。 X +XY *+XY-XY Infix Expression（中輟表達式） 一般人們可以識別、計算的運算式。 X X+Y (X+Y)*(X-Y) Postfix Expression（後輟表達式） 又稱逆波蘭表達式，其特點是沒有括號且運算符號在數字後面。 X XY+ XY+XY-* Evaluation 表達式的計算是基於運算符（operator）的優先級（precedence）和結合性（associativity），當表達式有多個運算符時，會依據運算符的優先級和結合性做評估，優先級高的運算符先求值，優先級低的最後求值。 30 + 8 * 3 / 2 在上面的中輟表達式中，* 和 / 的優先級相同，而 + 的優先級最低，根據運算符號的優先級，會先計算 * 和 / ，再做 + ，由於 * 和 / 有相同優先級，根據 golang operator associativity 計算順序會先執行 * ，再執行 / ，最後才執行 + ，因此上面的表達式的求值順序如下： 8 * 3 ---\u003e 24 24 / 2 ---\u003e 12 30 + 12 ---\u003e 42 Conversion 由於需要額外處理優先級，因此計算機很難評估中輟表達式，中輟表達式是人類編寫和識別的方式，通常也是程式的輸入方式，因此通常會將中輟主換成前輟或後輟。 ","date":"2022-11-29","objectID":"/stack/:2:2","tags":["stack","data structure"],"title":"Stack","uri":"/stack/"},{"categories":["data structure"],"content":"3. Backtracking Backtracking 是一種窮舉的搜尋法，會找尋所有可能的答案，可分為兩個概念； enumerate： 列出可能的答案在測試答案是否正確 pruning： 在找尋答案的過程中，只要遇到不符合的條件就回朔到上一步，不在繼續往下尋找 8 queens problem 如何在 8 x 8 的西洋棋盤上放 8 個皇后的棋子，且這 8 個皇后不會互相攻擊（也就是每個皇后的橫向、縱向、斜對角都沒有出現其他皇后）的所有解法。 Sudoku 數獨，是一種數學邏輯遊戲，你必須用 1 到 9 去填滿 9 x 9 的格子，且各數字的橫向、縱向皆不會出現重複的數字。 ","date":"2022-11-29","objectID":"/stack/:2:3","tags":["stack","data structure"],"title":"Stack","uri":"/stack/"},{"categories":["data structure"],"content":"4. String Reversal 利用 stack 先進後出的特性，反轉字串。 ","date":"2022-11-29","objectID":"/stack/:2:4","tags":["stack","data structure"],"title":"Stack","uri":"/stack/"},{"categories":["data structure"],"content":"5. Towers of Hanoi 河內塔是根據傳說形成的數學問題，有三根桿子分別是 A、B、C ，有 N 個圓盤疊在桿子 A 上，且這 N 個圓盤的尺寸由下到上依序變小，需在遵循以下條件的同時將所有圓盤移至桿子 C : 同一時間只能移動一個圓盤 小圓盤必須在大圓盤上 ","date":"2022-11-29","objectID":"/stack/:2:5","tags":["stack","data structure"],"title":"Stack","uri":"/stack/"},{"categories":["data structure"],"content":"Reference Data Structure and Algorithms - Stack Stack: Intro(簡介) Implementing Stacks in Data Structures Slice Based Stack Implementation in Golang ","date":"2022-11-29","objectID":"/stack/:3:0","tags":["stack","data structure"],"title":"Stack","uri":"/stack/"},{"categories":["instagram"],"content":"因 Meta Develop 開發政策，強制所有的用戶端 OAuth 都要使用 https 的 URL 才能被 Meta 認定為有效的 OAuth 重新導向 URL ，這會導致我們在地端測試時，會需要 https 的 URL 供我們做測試，這邊我們使用 ngrok 來產生一組 https 的 URL ，並帶著各位如何在地端使用 ngrok 來測試 instagram basic api ","date":"2022-08-09","objectID":"/instagram-basic/:0:0","tags":["instagram"],"title":"testing instagram basic api on localhost","uri":"/instagram-basic/"},{"categories":["instagram"],"content":"建立 instagram 的應用程式 ","date":"2022-08-09","objectID":"/instagram-basic/:1:0","tags":["instagram"],"title":"testing instagram basic api on localhost","uri":"/instagram-basic/"},{"categories":["instagram"],"content":"在 Meta 開發人員工具創建應用程式 到 Meta for Developers 建立應用程式 再來需要選擇應用程式的類型及填寫名稱，這邊需要注意類型的選擇會導致該應用程式可使用的產品、權限及功能，詳情可以參考官方文件 點選 instagram 基本顯示的設定 在 instagram 基本顯示 \u003e 基本顯示 中建立新的應用程式 ","date":"2022-08-09","objectID":"/instagram-basic/:1:1","tags":["instagram"],"title":"testing instagram basic api on localhost","uri":"/instagram-basic/"},{"categories":["instagram"],"content":"新增 instagram 測試人員 完成上面的步驟後，點選左邊選項中的 角色 \u003e instagram 測試人員的按鈕，輸入你要用來測試的 instagram 帳號 這時登入網頁版的 instagram ，在 設定 \u003e 應用程式和網站 \u003e 測試員邀請 ，會發現應用程式的邀請確認，點選接受就成功成為應用程式的測試人員 ","date":"2022-08-09","objectID":"/instagram-basic/:1:2","tags":["instagram"],"title":"testing instagram basic api on localhost","uri":"/instagram-basic/"},{"categories":["instagram"],"content":"建立一個 web 服務 這邊以 golang 搭建一個簡單的網頁並把服務放在 80 port package main import ( \"fmt\" \"log\" \"net/http\" ) func main() { http.HandleFunc(\"/ping\", func(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, \"pong\") }) log.Fatal(http.ListenAndServe(\":80\", nil)) } 把服務起起來並確認頁面有正常顯示，以上面範例，在瀏覽器 載入 localhost:80/ping 會出現以下圖例 ","date":"2022-08-09","objectID":"/instagram-basic/:2:0","tags":["instagram"],"title":"testing instagram basic api on localhost","uri":"/instagram-basic/"},{"categories":["instagram"],"content":"設定 ngrok ","date":"2022-08-09","objectID":"/instagram-basic/:3:0","tags":["instagram"],"title":"testing instagram basic api on localhost","uri":"/instagram-basic/"},{"categories":["instagram"],"content":"安裝 ngrok 先到 ngrok 官網 下載對應的版本並註冊登入會員，初次安裝需先驗證 ngrok 的 agent，到 Your Authtoken 執行 Command Line 的指令，會將 ngrok 的 Authtoken 保存在你的電腦，授於 agent 使用 ngrok 所有功能的權限 完成後執行 $ ngrok http {port} ，就可以將 localhost:{port} 的服務對外開放，因為我服務使用 80 port 的關係，所以我要執行 $ ngrok http 80 ，接著會看到以下圖片的樣子，就代表成功將地端的 80 port 對外開放，而紅色框框的 https 網址為你地端服務對外的網址，這時其他人就可以透過該網址連到你的網頁 ","date":"2022-08-09","objectID":"/instagram-basic/:3:1","tags":["instagram"],"title":"testing instagram basic api on localhost","uri":"/instagram-basic/"},{"categories":["instagram"],"content":"設定應用程式 回到 Meta for Developers 左邊選項的 instagram 基本顯示 \u003e 基本顯示 去設定 用戶端 OAuth 設定、取消授權、資料刪除要求，在圖中的三個欄位填入 ngrok 產生的 https 網址 ","date":"2022-08-09","objectID":"/instagram-basic/:3:2","tags":["instagram"],"title":"testing instagram basic api on localhost","uri":"/instagram-basic/"},{"categories":["instagram"],"content":"取得 instagram basic api 的 token ","date":"2022-08-09","objectID":"/instagram-basic/:4:0","tags":["instagram"],"title":"testing instagram basic api on localhost","uri":"/instagram-basic/"},{"categories":["instagram"],"content":"驗證測試人員 建構授權的視窗網址，{app-id} 為 instagram 基本顯示 \u003e 基本顯示 \u003e instagram 應用程式編號， {redirect-uri} 為有效的 OAuth 重新導向 URI的網址（網址必須完全相同） https://api.instagram.com/oauth/authorize ?client_id={app-id} \u0026redirect_uri={redirect-uri} \u0026scope=user_profile,user_media \u0026response_type=code 以我們剛剛產生的 https 網址為例 https://api.instagram.com/oauth/authorize ?client_id=135421602932815 \u0026redirect_uri=https://6e02-220-135-89-54.jp.ngrok.io/ping \u0026scope=user_profile,user_media \u0026response_type=code 在瀏覽器載入網址後，會出現應用程式要求權限的說明 點選允許後，會跳轉到你在應用程式設定的重新導向 URI的頁面，這時請觀察該網頁的網址 網址中的 code 到 #_ 之間為測試人員的授權碼 https://6e02-220-135-89-54.jp.ngrok.io/ping?code=AQAODGH_DePavKuPRK0UKy5nMnSBYG_EEjOcodAUC5Q-wVS0uP5SDjFNgNWdw2a4plybIndmH0CuPKvx5k-IDNlVh4sX2qjao1LKGRykYNvpn_6gTtYWYPDrcJR0Lt5JrWHdo5Nj70cBg6VMDeW-vyzEAXzgnfgUTg3FeOfdJ2vlBenmCsMqwCrOS2SSQzMLEGK1B7osZz7W8ckAGkiyYZUGTOTlIDDuy4UOpLJ_PJd_4g#_ ","date":"2022-08-09","objectID":"/instagram-basic/:4:1","tags":["instagram"],"title":"testing instagram basic api on localhost","uri":"/instagram-basic/"},{"categories":["instagram"],"content":"將授權碼換成 token 將 {app-id} 、 {app-secret} 、 {redirect-uri} 、 {code} 換成你的 instagram 應用程式編號、 instagram 應用程式密鑰 、重新導向 URI 、授權碼，並輸入指令傳送請求 curl -X POST https://api.instagram.com/oauth/access_token \\ -F client_id={app-id} \\ -F client_secret={app-secret} \\ -F grant_type=authorization_code \\ -F redirect_uri={redirect-uri} \\ -F code={code} 成功時，會回傳以下 json 格式 { \"access_token\": \"IGQVJV...\", \"user_id\": 178414005245354752 } 例如： 這時候就可以用 access_token 和 user_id 去串接 instagram basic api 了 ","date":"2022-08-09","objectID":"/instagram-basic/:4:2","tags":["instagram"],"title":"testing instagram basic api on localhost","uri":"/instagram-basic/"},{"categories":["instagram"],"content":"Reference Meta for Developers 產品開發 | 如何在Localhost實作與測試FB Login SDK功能 ","date":"2022-08-09","objectID":"/instagram-basic/:5:0","tags":["instagram"],"title":"testing instagram basic api on localhost","uri":"/instagram-basic/"},{"categories":["golang"],"content":"Go 的標準函式庫可以很容易的對 JSON 資料進行編、解碼的工作。 ","date":"2022-06-09","objectID":"/golang-json/:0:0","tags":["golang","json"],"title":"用 golang 處理 json 資料","uri":"/golang-json/"},{"categories":["golang"],"content":"json 資料轉換 ","date":"2022-06-09","objectID":"/golang-json/:1:0","tags":["golang","json"],"title":"用 golang 處理 json 資料","uri":"/golang-json/"},{"categories":["golang"],"content":"struct 在處理 struct 與 json 資料轉換時，只要 struct 內元素的名稱字首是大寫，就可以轉換成 json struct 轉換成 json json 的 key 會跟 struct 元素名稱一樣 type Person struct { Name string Age int } func main() { p := Person{ Name: \"vito\", Age: 11, } b, err := json.Marshal(p) if err != nil { fmt.Println(\"err: \", err) } fmt.Println(string(b)) // output: {\"Name\":\"vito\",\"Age\":11} } json 轉換成 struct 沒有加 struct tag 的情況下不管大小寫，只要字母是一樣即可將 json 轉換成 struct type Person struct { Personname string Age int } func main() { j := []byte(`{ \"personName\":\"vito\", \"age\":11 }`) p := Person{} if err := json.Unmarshal(j, \u0026p); err != nil { fmt.Println(\"err: \", err) } fmt.Println(p) // output: {vito 11} } ","date":"2022-06-09","objectID":"/golang-json/:1:1","tags":["golang","json"],"title":"用 golang 處理 json 資料","uri":"/golang-json/"},{"categories":["golang"],"content":"map map 轉換成 json func main() { m := map[string]interface{}{ \"name\": \"vito\", \"age\": 11, } b, err := json.Marshal(m) if err != nil { fmt.Println(\"err: \", err) } fmt.Println(string(b)) // output: {\"age\":11,\"name\":\"vito\"} } json 轉換成 map func main() { j := []byte(`{ \"name\":\"vito\", \"age\":11 }`) var m map[string]interface{} if err := json.Unmarshal(j, \u0026m); err != nil { fmt.Println(\"err: \", err) } fmt.Println(m) // output: map[age:11 name:vito] } ","date":"2022-06-09","objectID":"/golang-json/:1:2","tags":["golang","json"],"title":"用 golang 處理 json 資料","uri":"/golang-json/"},{"categories":["golang"],"content":"struct tag 可以看到上面 struct 轉成 json 的範例，轉換後的 key 都是大寫，如果今天你想要 key 是小寫的該怎麼辦呢？golang 提供了 struct tag 來實現 type Person struct { Name string `json:\"name\"` Age int `json:\"age\"` } func main() { p := Person{ Name: \"vito\", Age: 11, } b, err := json.Marshal(p) if err != nil { fmt.Println(\"err: \", err) } fmt.Println(string(b)) // output: {\"name\":\"vito\",\"age\":11} } 也可以透過 json tag 定義 key 值 type Person struct { Name string `json:\"person_name\"` Age int `json:\"person_age\"` } func main() { p := Person{ Name: \"vito\", Age: 11, } b, err := json.Marshal(p) if err != nil { fmt.Println(\"err: \", err) } fmt.Println(string(b)) // output: {\"person_name\":\"vito\",\"person_age\":11} } ","date":"2022-06-09","objectID":"/golang-json/:2:0","tags":["golang","json"],"title":"用 golang 處理 json 資料","uri":"/golang-json/"},{"categories":["golang"],"content":"omitempty 忽略空值 當結構體元素是默認值時，想要忽略它，可以使用 omitempty type Person struct { Name string `json:\"name,omitempty\"` Age int `json:\"age,omitempty\"` Address string `json:\"address,omitempty\"` } func main() { p := Person{ Name: \"vito\", Age: 11, } b, err := json.Marshal(p) if err != nil { fmt.Println(\"err: \", err) } fmt.Println(string(b)) // {\"name\":\"vito\",\"age\":11} // 當 Address 為默認值 \"\" 時，會忽略該元素 } 忽略 struct 當想忽略 Person 中的 School 時，則 School 必須是 pointer type Person struct { Name string `json:\"name,omitempty\"` Age int `json:\"age,omitempty\"` Address string `json:\"address,omitempty\"` // 若 School 不是 pointer ，就算加 omitempty 也無法忽略它 School *School `json:\"school,omitempty\"` } type School struct { Name string `json:\"name\"` Address string `json:\"address\"` } func main() { p := Person{ Name: \"vito\", Age: 11, } b, err := json.Marshal(p) if err != nil { fmt.Println(\"err: \", err) } fmt.Println(string(b)) // {\"name\":\"vito\",\"age\":11} } ","date":"2022-06-09","objectID":"/golang-json/:2:1","tags":["golang","json"],"title":"用 golang 處理 json 資料","uri":"/golang-json/"},{"categories":["golang"],"content":"string 轉換成 json 時，將型態轉為字串 type Person struct { Name string `json:\"name\"` Age int `json:\"age,string\"` } func main() { p := Person{ Name: \"vito\", Age: 11, } b, err := json.Marshal(p) if err != nil { fmt.Println(\"err: \", err) } fmt.Println(string(b)) // age 的值被轉為文字型態 // output: {\"name\":\"vito\",\"age\":\"11\"} } json 轉換 struct 將 json 格式的 age 的值（type: string） 轉換成 struct 時，原先 age 的型態會被轉成 int type Person struct { Name string `json:\"name\"` Age int `json:\"age,string\"` } func main() { // 原始的 json 資料， age 的值是文字型態的 11 j := []byte(`{ \"name\":\"vito\", \"age\":\"11\" }`) var p Person if err := json.Unmarshal(j, \u0026p); err != nil { fmt.Println(\"err: \", err) } fmt.Println(p) // output: {vito 11} fmt.Printf(\"%T\\n\", p.Age) // 轉換成 struct 後，原先文字型態的 11 變成 int 型態的 11 // output: int } 當要轉換成 struct 時，如果型態有錯誤，會回傳錯誤訊息，但還是會成功轉換成 struct ，只是型態有問題的元素的值會是默認值，而不是你的資料 type Person struct { Name string `json:\"name\"` Age int `json:\"age,string\"` } func main() { j := []byte(`{ \"name\":\"vito\", \"age\":\"11.1\" }`) var p Person if err := json.Unmarshal(j, \u0026p); err != nil { // 預計 json age 的值會變轉成 int ，但 json age 的值轉換後是 float ，所以出現錯誤 fmt.Println(\"err: \", err) // err: json: cannot unmarshal number 11.1 into Go struct field Person.age of type int } fmt.Println(p) // output: {vito 0} } ","date":"2022-06-09","objectID":"/golang-json/:2:2","tags":["golang","json"],"title":"用 golang 處理 json 資料","uri":"/golang-json/"},{"categories":["golang"],"content":"- 不管是否有資料想忽略元素可以用 - type Person struct { Name string `json:\"name\"` Age int `json:\"-\"` } func main() { p := Person{ Name: \"vito\", Age: 11, } b, err := json.Marshal(p) if err != nil { fmt.Println(\"err: \", err) } fmt.Println(string(b)) // output: {\"name\":\"vito\"} } 若只是想讓 json 的 key 是 - 時，只需要再加上 , type Person struct { Name string `json:\"name\"` Age int `json:\"-,\"` } func main() { p := Person{ Name: \"vito\", Age: 11, } b, err := json.Marshal(p) if err != nil { fmt.Println(\"err: \", err) } fmt.Println(string(b)) // output: {\"name\":\"vito\",\"-\":11} } ","date":"2022-06-09","objectID":"/golang-json/:2:3","tags":["golang","json"],"title":"用 golang 處理 json 資料","uri":"/golang-json/"},{"categories":["heroku"],"content":"軟體 pgAdmin Heroku PostgreSQL project ","date":"2021-10-05","objectID":"/operate-heroku-pg-using-pgadmin/:1:0","tags":["heroku","postgres"],"title":"透過 pgAdmin 操作 Heroku PostgreSQL Database","uri":"/operate-heroku-pg-using-pgadmin/"},{"categories":["heroku"],"content":"建立 postgres 登入Heroku，進到有Postgre專案的Resource，點擊Heroku Postgres 點選settings，我們需要 ‘Host’、‘Database’、‘User’、‘Port’、‘Password’ 的資訊 ","date":"2021-10-05","objectID":"/operate-heroku-pg-using-pgadmin/:2:0","tags":["heroku","postgres"],"title":"透過 pgAdmin 操作 Heroku PostgreSQL Database","uri":"/operate-heroku-pg-using-pgadmin/"},{"categories":["heroku"],"content":"建立與Heroku PostgreSQL資料庫的連結設定 開啟pgAdmin，在左上角的Servers點擊右鍵 →Create →Server… 在General標簽頁中，Name 欄位輸入可識別的名稱 在Connection標簽頁中 Host name/address 對應 Heroku Postgres的Host Port 對應 Heroku Postgres的Port Maintenance database 對應 Heroku Postgres的Database Username 對應 Heroku Postgres的User Password 對應 Heroku Postgres的Password Save password 勾選起來 在SSL標簽頁中，SSLmode 選擇Allow 關於其他選項可參考文件 在Advanced標簽頁中 DB restriction對應 Heroku Postgres的Database 點擊下方 Save存儲 存儲後打開的畫面可以看到在Heroku PostgreSQL的所有資料表都在Tables標籤下 ","date":"2021-10-05","objectID":"/operate-heroku-pg-using-pgadmin/:3:0","tags":["heroku","postgres"],"title":"透過 pgAdmin 操作 Heroku PostgreSQL Database","uri":"/operate-heroku-pg-using-pgadmin/"},{"categories":["heroku"],"content":"利用SQL語法來查詢資料庫的資料 在左邊的框框點擊右鍵選擇Query Tool 輸入SQL語法點擊右上方的三角形圖案執行命令 ","date":"2021-10-05","objectID":"/operate-heroku-pg-using-pgadmin/:4:0","tags":["heroku","postgres"],"title":"透過 pgAdmin 操作 Heroku PostgreSQL Database","uri":"/operate-heroku-pg-using-pgadmin/"},{"categories":["git"],"content":"建立 ssh key 和 git clone 、 git push 教學 GitHub 提供了兩種連線方式，分別是https與ssh，兩者最大的差別在於ssh可以立刻上傳，不需要輸入密碼，且安全性高。 ","date":"2021-05-17","objectID":"/git-clone-ssh-key/:0:0","tags":["ssh key"],"title":"Git Clone With SSH Key","uri":"/git-clone-ssh-key/"},{"categories":["git"],"content":"如何透過ssh連結GitHub 第一步：依作業系統下載對應的Git(本示範系統是macos) (或透過Homebrew download: $ brew install git) 第二步：產生金鑰 $ ssh-keygen -t rsa -b 4096 -C ' your id ' 用ssh-keygen建立金鑰 系統會請你輸入通行碼(若沒輸入直接回車，之後clone就不用輸入密碼) 再輸入一次通行碼後會顯示ssh的公鑰及私鑰路徑檔名 第三步： 將id_rsa.pub(公鑰)的內容新增到GitHub的Settings的SSH keys (公鑰的內容) $ cat ./.ssh/id_rsa.pub 點擊Add就大功告成！！！ ","date":"2021-05-17","objectID":"/git-clone-ssh-key/:1:0","tags":["ssh key"],"title":"Git Clone With SSH Key","uri":"/git-clone-ssh-key/"},{"categories":["git"],"content":"clone 第一步：先在終端機進到你要建立專案的地方。 $ cd 要建立專案的地方 第二步：clone 專案到本機 $ get clone '專案ssh網址' 第三部：輸入通行碼(若當初有設定的話) 下圖表示成功將專案裡的檔案clone到主機 clone下來的資料夾名稱會是你的GitHub的repository名稱 ","date":"2021-05-17","objectID":"/git-clone-ssh-key/:2:0","tags":["ssh key"],"title":"Git Clone With SSH Key","uri":"/git-clone-ssh-key/"},{"categories":["git"],"content":"push 第一步：示範新增一個名為README.md的檔案 並將新檔案丟到專案(xxxVitoxxx.github.io)的資料夾裡，並cd到專案的資料夾 第二步：確認專案的資料夾做了哪些更動 $ git status (紅色字體代表有更改過的檔案) 第三步：將新增的檔案加到Git版本控管 $ git add . (注意！！！這邊只是將專案資料夾的所有檔案加到Git工作目錄的索引中，尚未加到Git版本庫)。 可以再輸入一次 $ git status 確認專案資料夾的檔案是否已成功更新(綠色字體代表成功更新檔案) 第四步：為修改記錄命名一個名稱 $ git commit -m \"commit message\" 這邊將第一次修改記錄命名為’first commit' $ git log 可以查看該專案的修改紀錄 第五步： $ git push 將剛剛新增的檔案推到GitHub上 ","date":"2021-05-17","objectID":"/git-clone-ssh-key/:3:0","tags":["ssh key"],"title":"Git Clone With SSH Key","uri":"/git-clone-ssh-key/"},{"categories":null,"content":"About","date":"2019-08-02","objectID":"/about/","tags":null,"title":"About","uri":"/about/"}]