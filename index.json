[{"categories":["algorithm"],"content":"Floyd Cycle Detection Algorithm 或 Hare-Tortoise Algorithm 是一種指針演算法。它使用兩個 pointer，以不同的速度移動，速度較快的稱為 fast ，速度較慢的稱為 slow ，所以又稱為 Fast-Slow Pointers 。 ","date":"2023-10-09","objectID":"https://xxxVitoxxx.github.io/2023/10/floyd_cycle_detection_algorithm/:0:0","tags":["algorithm"],"title":"Floyd Cycle Detection Algorithm","uri":"https://xxxVitoxxx.github.io/2023/10/floyd_cycle_detection_algorithm/"},{"categories":["algorithm"],"content":"Introduction 兩個 pointer 分別為 fast 和 slow 沿著 Linked List 遍歷，fast 移動的速度會比 slow 快。一般情況下， slow 每次會往前一步，而 fast 往前的步數會是 slow 的兩倍。 關鍵思想是 fast 和 slow 會從同一個位置以不同速度遍歷 Linked List ，如果存在 cycle ，兩者必然會在 cycle 中的某個點相遇。就像有兩位跑者在跑道上，雖然起跑點是一樣的，但由於某一方速度較快，且如果跑道是圓的情況下，那速度較快的跑者勢必會在某個點遇到跑得慢的跑者。另一方面如果跑道是直的，那跑的快的跑者會優先跑到終點，且過程中不會與速度較慢的跑者相遇。 ","date":"2023-10-09","objectID":"https://xxxVitoxxx.github.io/2023/10/floyd_cycle_detection_algorithm/:1:0","tags":["algorithm"],"title":"Floyd Cycle Detection Algorithm","uri":"https://xxxVitoxxx.github.io/2023/10/floyd_cycle_detection_algorithm/"},{"categories":["algorithm"],"content":"Use case 使用 Fast-Slow Pointers 可以解決以下幾種問題： 判斷 Linked List 有沒有 cycle 找到 Linked List 的中心點 計算 cycle 的長度 找到 cycle 的起始點 ","date":"2023-10-09","objectID":"https://xxxVitoxxx.github.io/2023/10/floyd_cycle_detection_algorithm/:2:0","tags":["algorithm"],"title":"Floyd Cycle Detection Algorithm","uri":"https://xxxVitoxxx.github.io/2023/10/floyd_cycle_detection_algorithm/"},{"categories":["algorithm"],"content":"判斷 Linked List 有沒有 cycle 如果 Linked List 有 cycle 的情況下 fast 與 slow 一定會相遇，而沒有 cycle 的情況下兩者不會相遇。 type ListNode struct { Val int Next *ListNode } func hasCycle(head *ListNode) bool { fast, slow := head, head for fast != nil \u0026\u0026 fast.Next != nil { fast = fast.Next.Next slow = slow.Next if fast == slow { return true } } return false } ","date":"2023-10-09","objectID":"https://xxxVitoxxx.github.io/2023/10/floyd_cycle_detection_algorithm/:2:1","tags":["algorithm"],"title":"Floyd Cycle Detection Algorithm","uri":"https://xxxVitoxxx.github.io/2023/10/floyd_cycle_detection_algorithm/"},{"categories":["algorithm"],"content":"找到 Linked List 的中心點 因為 fast 移動的距離是 slow 的兩倍，所以當 fast 到終點時 slow 會在 Linked List 的中心點。 func findCenterPointer(head *ListNode) *ListNode { fast, slow := head, head for fast != nil \u0026\u0026 fast.Next != nil { fast = fast.Next.Next slow = slow.Next } return slow } ","date":"2023-10-09","objectID":"https://xxxVitoxxx.github.io/2023/10/floyd_cycle_detection_algorithm/:2:2","tags":["algorithm"],"title":"Floyd Cycle Detection Algorithm","uri":"https://xxxVitoxxx.github.io/2023/10/floyd_cycle_detection_algorithm/"},{"categories":["algorithm"],"content":"Cycle 的長度 當 fast 與 slow 相遇時，那相遇的點一定會在 cycle 中，這時 slow 繼續前走並計算走的步數。當 slow 再次與 fast 相遇時，走的步數就會是 cycle 的長度。 func cycleLength(head *ListNode) int { fast, slow := head, head for fast != nil \u0026\u0026 fast.Next != nil { fast = fast.Next.Next slow = slow.Next if fast == slow { var l int for slow != nil { l++ slow = slow.Next if slow == fast { return l } } } } return 0 } ","date":"2023-10-09","objectID":"https://xxxVitoxxx.github.io/2023/10/floyd_cycle_detection_algorithm/:2:3","tags":["algorithm"],"title":"Floyd Cycle Detection Algorithm","uri":"https://xxxVitoxxx.github.io/2023/10/floyd_cycle_detection_algorithm/"},{"categories":["algorithm"],"content":"找到 cycle 的起始點 假設有一個 cycle 的 Linked List ，由 head 到 cycle 起始點的長度為 X ，而 cycle 的長度為 Y ，可以得知整個 Linked List 的長度為 X + Y 。 在已知 cycle 長度的情況下， 假設 pointer 1 和 pointer 2 都在 head 上，先讓 pointer 1 移動 Y 步。我們觀察一下 pointer 1 和 pointer 2 的位置， pointer 1 已經走了 Y 步，如果再走 X 步剛好遍歷過整個 Linked List 回到 cycle 的起始點，而 pointer 2 還在 head 上，所以走 X 步就會到 cycle 的起始點。 我們已經知道 pointer 1 和 pointer 2 雙方只要走 X 步就可以到 cycle 的起始點並相遇，換句話說，只要讓 pointer 1 和 pointer 2 以等速移動，那雙方相遇的點就是 cycle 的起始點。 整理一下步驟： step1: 利用 Fast-Slow Pointers 找出在 cycle 相遇的點 step2: 計算 cycle 的長度為 L step3: 一個 pointer 先從 head 往前走 L 步，另一個 pointer 在 head ，接著兩個 pointer 等速移動直到相遇 func detectCycle(head *ListNode) *ListNode { fast, slow := head, head for fast != nil \u0026\u0026 fast.Next != nil { fast = fast.Next.Next slow = slow.Next if fast == slow { l := cycleLen(slow) pnt1, pnt2 := head, head for l \u003e 0 { pnt1 = pnt1.Next l-- } for pnt1 != pnt2 { pnt1 = pnt1.Next pnt2 = pnt2.Next } return pnt1 } } return nil } func cycleLen(node *ListNode) int { var l int curry := node for curry != nil { l++ curry = curry.Next if curry == node { return l } } return 0 } 前面的方法在找到相遇的點後還需要額外執行 for 迴圈來尋找 cycle 長度。接下來我們用另一種與前面類似的方法但不需要尋找 cycle 長度。 在有 cycle 的情況下，假設 A 點為 Linked List 的 head ， B 點為 cycle 的起始點， C 點為 fast pointer 和 slow pointer 相遇的點。 X 為 A 點到 B 點的距離， Y 為 B 點到 C 點的距離， Z 為 C 點到 B 點的距離。 會發現當 slow pointer 走了 X + Y ， fast pointer 走了 X + Y + n * (Y + Z) ( n 為循環的次數)，在 fast pointer 移動的速度是 slow pointer 的 2 倍時可以得到 2 * (X + Y) = X + Y + n * (Y + Z) ，簡化後為 X + Y = n * (Y + Z)。因為我們想知道 B 點的位置，所以我們要得到 X 的距離，求 X 的方程式為 X = (n - 1) * Y + n * Z 。 現在我們知道如何得到 X 的長度了，假設 n = 1 ，會得到 X = Z ，這代表如果我在 A 點和 C 點各放一個 pointer ，雙方以相同的速度前進，雙方會在 B 點相遇，也就是 cycle 的起始點。 整理一下步驟： step1: 利用 Fast-Slow Pointers 找出在 cycle 相遇的點 step2: 將 fast 指回 head 的位置 step3: fast 和 slow 等速往前走直到相遇 func detectCycle(head *ListNode) *ListNode { fast, slow := head, head for fast != nil \u0026\u0026 fast.Next != nil { fast = fast.Next.Next slow = slow.Next if fast == slow { fast = head for fast != slow { fast = fast.Next slow = slow.Next } return slow } } return nil } ","date":"2023-10-09","objectID":"https://xxxVitoxxx.github.io/2023/10/floyd_cycle_detection_algorithm/:2:4","tags":["algorithm"],"title":"Floyd Cycle Detection Algorithm","uri":"https://xxxVitoxxx.github.io/2023/10/floyd_cycle_detection_algorithm/"},{"categories":["algorithm"],"content":"Related topics in leetcode leetcode 141 leetcode 142 leetcode 143 leetcode 202 leetcode 234 leetcode 457 leetcode 876 ","date":"2023-10-09","objectID":"https://xxxVitoxxx.github.io/2023/10/floyd_cycle_detection_algorithm/:3:0","tags":["algorithm"],"title":"Floyd Cycle Detection Algorithm","uri":"https://xxxVitoxxx.github.io/2023/10/floyd_cycle_detection_algorithm/"},{"categories":["algorithm"],"content":"Reference Fast and Slow Pointers: Introduction 快慢指針（Fast-slow Pointers） 探索 Floyd Cycle Detection Algorithm leetcode算法汇总 （三）快慢指针 ","date":"2023-10-09","objectID":"https://xxxVitoxxx.github.io/2023/10/floyd_cycle_detection_algorithm/:4:0","tags":["algorithm"],"title":"Floyd Cycle Detection Algorithm","uri":"https://xxxVitoxxx.github.io/2023/10/floyd_cycle_detection_algorithm/"},{"categories":["data structure"],"content":"二元樹是一種樹狀的資料結構，本文章將會介紹六種不同的二元樹及如何實作。 ","date":"2023-05-01","objectID":"https://xxxVitoxxx.github.io/2023/05/binary_tree/:0:0","tags":["data structure","tree"],"title":"Binary Tree","uri":"https://xxxVitoxxx.github.io/2023/05/binary_tree/"},{"categories":["data structure"],"content":"Introduction 二元樹是一種分層式的資料結構，由 Node 組成且每個 Node 最多只能有 2 個 Child ，分別稱為 Left Node 和 Right Node 。 Node 由以下三點組成： data element pointer of left node pointer of right node ","date":"2023-05-01","objectID":"https://xxxVitoxxx.github.io/2023/05/binary_tree/:1:0","tags":["data structure","tree"],"title":"Binary Tree","uri":"https://xxxVitoxxx.github.io/2023/05/binary_tree/"},{"categories":["data structure"],"content":"Types of Binary Tree ","date":"2023-05-01","objectID":"https://xxxVitoxxx.github.io/2023/05/binary_tree/:2:0","tags":["data structure","tree"],"title":"Binary Tree","uri":"https://xxxVitoxxx.github.io/2023/05/binary_tree/"},{"categories":["data structure"],"content":"Full Binary Tree 圖片來源 https://www.programiz.com/dsa/binary-tree 每個 Node 都有 0 或 2 個 Child 時，稱為 Full Binary Tree 。 ","date":"2023-05-01","objectID":"https://xxxVitoxxx.github.io/2023/05/binary_tree/:2:1","tags":["data structure","tree"],"title":"Binary Tree","uri":"https://xxxVitoxxx.github.io/2023/05/binary_tree/"},{"categories":["data structure"],"content":"Complete Binary Tree 圖片來源 https://www.programiz.com/dsa/binary-tree Complete Binary Tree 跟 Full Binary Tree 很相似，但有以下幾點不同。 除了最後一層之外，所有層都必須被完整填充 最後一層（Leaf Layer）從左邊開始填充 最後一個 Leaf（6） 可能會沒有 Right Sibling ","date":"2023-05-01","objectID":"https://xxxVitoxxx.github.io/2023/05/binary_tree/:2:2","tags":["data structure","tree"],"title":"Binary Tree","uri":"https://xxxVitoxxx.github.io/2023/05/binary_tree/"},{"categories":["data structure"],"content":"Perfect Binary Tree 圖片來源 https://www.programiz.com/dsa/binary-tree 所有 Leaf 都在同一層，且除了 Leaf 之外的 Node 都有 2 個 Child 。 ","date":"2023-05-01","objectID":"https://xxxVitoxxx.github.io/2023/05/binary_tree/:2:3","tags":["data structure","tree"],"title":"Binary Tree","uri":"https://xxxVitoxxx.github.io/2023/05/binary_tree/"},{"categories":["data structure"],"content":"Degenerate or Pathological Tree 圖片來源 https://www.programiz.com/dsa/binary-tree 稱為退化樹或病態樹，除了 Leaf 之外，每個 Node 都有一個 Child ，不是 Left Node 就是 Right Node 。 ","date":"2023-05-01","objectID":"https://xxxVitoxxx.github.io/2023/05/binary_tree/:2:4","tags":["data structure","tree"],"title":"Binary Tree","uri":"https://xxxVitoxxx.github.io/2023/05/binary_tree/"},{"categories":["data structure"],"content":"Skewed Binary Tree 圖片來源 https://www.programiz.com/dsa/binary-tree 也是退化樹/病態樹的一種，其 Child 全部都在左側或右側。依照向左或向右傾斜又可分為 Left-Skewed Binary Tree 和 Right-Skewed Binary Tree 。 ","date":"2023-05-01","objectID":"https://xxxVitoxxx.github.io/2023/05/binary_tree/:2:5","tags":["data structure","tree"],"title":"Binary Tree","uri":"https://xxxVitoxxx.github.io/2023/05/binary_tree/"},{"categories":["data structure"],"content":"Balanced Binary Tree 圖片來源 https://www.programiz.com/dsa/binary-tree 每個 Node 的 Left Subtree 和 Right Subtree 高度只相差 1 或 0 。 ","date":"2023-05-01","objectID":"https://xxxVitoxxx.github.io/2023/05/binary_tree/:2:6","tags":["data structure","tree"],"title":"Binary Tree","uri":"https://xxxVitoxxx.github.io/2023/05/binary_tree/"},{"categories":["data structure"],"content":"Implement Bainary Tree 用 Linked List 實作 Binary Tree ，完整程式碼。 ","date":"2023-05-01","objectID":"https://xxxVitoxxx.github.io/2023/05/binary_tree/:3:0","tags":["data structure","tree"],"title":"Binary Tree","uri":"https://xxxVitoxxx.github.io/2023/05/binary_tree/"},{"categories":["data structure"],"content":"Declare Structure type Node struct { value int left, right *Node } type BinaryTree struct { root *Node } func createNode(value int) *Node { return \u0026Node{value: value} } func newBinaryTree(value int) *BinaryTree { return \u0026BinaryTree{ root: \u0026Node{value: value}, } } 第 1 ~ 4 行：宣告 Node 有三個屬性，分別是資料跟 Left Node 和 Right Node 。 第 6 ~ 8 行：宣告名稱為 Binary Tree 的 Linked List 。 第 10 ~ 12 行：建立 Node 的方法。 第 14 ~ 18 行：建立 Linked List 的方法。 ","date":"2023-05-01","objectID":"https://xxxVitoxxx.github.io/2023/05/binary_tree/:3:1","tags":["data structure","tree"],"title":"Binary Tree","uri":"https://xxxVitoxxx.github.io/2023/05/binary_tree/"},{"categories":["data structure"],"content":"Implement Count the Number of Node in a Tree func (root *Node) GetNodeCount() int { if root == nil { return 0 } return root.left.GetNodeCount() + root.right.GetNodeCount() + 1 } 使用 recursion 實作計算該樹共有多少 Node 。 ","date":"2023-05-01","objectID":"https://xxxVitoxxx.github.io/2023/05/binary_tree/:3:2","tags":["data structure","tree"],"title":"Binary Tree","uri":"https://xxxVitoxxx.github.io/2023/05/binary_tree/"},{"categories":["data structure"],"content":"Implement Count Degree of a Tree func (root *Node) GetTreeDegree() int { if root != nil { var maxDegree int queue := append([]*Node{}, root) for len(queue) != 0 { element := queue[0] queue = queue[1:] var degree int if element.left != nil { degree += 1 queue = append(queue, element.left) } if element.right != nil { degree += 1 queue = append(queue, element.right) } if degree \u003e maxDegree { maxDegree = degree } } return maxDegree } return 0 } 實作計算樹的 Degree 。 ","date":"2023-05-01","objectID":"https://xxxVitoxxx.github.io/2023/05/binary_tree/:3:3","tags":["data structure","tree"],"title":"Binary Tree","uri":"https://xxxVitoxxx.github.io/2023/05/binary_tree/"},{"categories":["data structure"],"content":"Implement Search func (root *Node) Search(value int) (*Node, error) { if root != nil { queue := append([]*Node{}, root) for len(queue) != 0 { element := queue[0] queue = queue[1:] if element.value == value { return element, nil } if element.left != nil { queue = append(queue, element.left) } if element.right != nil { queue = append(queue, element.right) } } } return \u0026Node{}, errors.New(\"the value not exist in node of a tree\") } 實作搜尋資料是否存在樹中的 Node 。 ","date":"2023-05-01","objectID":"https://xxxVitoxxx.github.io/2023/05/binary_tree/:3:4","tags":["data structure","tree"],"title":"Binary Tree","uri":"https://xxxVitoxxx.github.io/2023/05/binary_tree/"},{"categories":["data structure"],"content":"Implement Preorder Traversal func (root *Node) Preorder() { if root != nil { fmt.Printf(\"-\u003e %v \", root.value) root.left.Preorder() root.right.Preorder() } } 使用 recursion 實作前序遍歷。 前序遍歷的輸出順序為： Root -\u003e Left Node -\u003e Right Node 。 ","date":"2023-05-01","objectID":"https://xxxVitoxxx.github.io/2023/05/binary_tree/:3:5","tags":["data structure","tree"],"title":"Binary Tree","uri":"https://xxxVitoxxx.github.io/2023/05/binary_tree/"},{"categories":["data structure"],"content":"Implement Inorder Traversal func (root *Node) Inorder() { if root != nil { root.left.Inorder() fmt.Printf(\"-\u003e %v \", root.value) root.right.Inorder() } } 使用 recursion 實作中序遍歷。 中序遍歷的輸出順序為： Left Node -\u003e Root -\u003e Right Node 。 ","date":"2023-05-01","objectID":"https://xxxVitoxxx.github.io/2023/05/binary_tree/:3:6","tags":["data structure","tree"],"title":"Binary Tree","uri":"https://xxxVitoxxx.github.io/2023/05/binary_tree/"},{"categories":["data structure"],"content":"Implement Postorder Traversal func (root *Node) Postorder() { if root != nil { root.left.Postorder() root.right.Postorder() fmt.Printf(\"-\u003e %v \", root.value) } } 使用 recursion 實作後序遍歷。 後序遍歷的輸出順序為： Left Node -\u003e Right Node -\u003e Root 。 ","date":"2023-05-01","objectID":"https://xxxVitoxxx.github.io/2023/05/binary_tree/:3:7","tags":["data structure","tree"],"title":"Binary Tree","uri":"https://xxxVitoxxx.github.io/2023/05/binary_tree/"},{"categories":["data structure"],"content":"Implement Layer-Order Traversal func (root *Node) LayerOrder() { if root == nil { return } var queue []*Node queue = append(queue, root) for len(queue) != 0 { node := queue[0] queue = queue[1:] fmt.Printf(\"-\u003e %v \", node.value) if node.left != nil { queue = append(queue, node.left) } if node.right != nil { queue = append(queue, node.right) } } } 使用 queue 實作階層式遍歷。 階層式遍歷的輸出順序為先輸出 Root 再依序 Left Node -\u003e Right Node 輸出。 ","date":"2023-05-01","objectID":"https://xxxVitoxxx.github.io/2023/05/binary_tree/:3:8","tags":["data structure","tree"],"title":"Binary Tree","uri":"https://xxxVitoxxx.github.io/2023/05/binary_tree/"},{"categories":["data structure"],"content":"因為他跟倒過來的樹很相似，所以被稱為 Tree，日常中，許多應用都與他脫離不了關係，像是組織架構圖、資料儲存、 sitemap 等等… 若熟悉 Linked List 將會更容易理解 Tree ，想了解 Linke List 可以參考文章。 ","date":"2023-04-24","objectID":"https://xxxVitoxxx.github.io/2023/04/tree/:0:0","tags":["tree","data structure"],"title":"Tree","uri":"https://xxxVitoxxx.github.io/2023/04/tree/"},{"categories":["data structure"],"content":"Introduction 圖片來源 https://www.geeksforgeeks.org/introduction-to-tree-data-structure-and-algorithm-tutorials/ Tree 是一種非線性資料結構，由 node 集合組成的階層式結構，且 Node 之間會透過 Edge 連接，表明兩個節點之間的關係。 ","date":"2023-04-24","objectID":"https://xxxVitoxxx.github.io/2023/04/tree/:1:0","tags":["tree","data structure"],"title":"Tree","uri":"https://xxxVitoxxx.github.io/2023/04/tree/"},{"categories":["data structure"],"content":"Basic Terminologies in Tree Data Structure ","date":"2023-04-24","objectID":"https://xxxVitoxxx.github.io/2023/04/tree/:2:0","tags":["tree","data structure"],"title":"Tree","uri":"https://xxxVitoxxx.github.io/2023/04/tree/"},{"categories":["data structure"],"content":"Node 是 Tree 基本組成的一部分，它是一種結構，包含本身資料及 Child 的 Pointer 。 ","date":"2023-04-24","objectID":"https://xxxVitoxxx.github.io/2023/04/tree/:2:1","tags":["tree","data structure"],"title":"Tree","uri":"https://xxxVitoxxx.github.io/2023/04/tree/"},{"categories":["data structure"],"content":"Edge 是 Tree 的另一個基本組成，它連接兩個 Node 表示兩個 Node 之間的關係，每個 Node 可能會有數條 Outgoing Edge ，除了 Root 之外，每個 Node 一定會有一條 Incoming Edge 。 ","date":"2023-04-24","objectID":"https://xxxVitoxxx.github.io/2023/04/tree/:2:2","tags":["tree","data structure"],"title":"Tree","uri":"https://xxxVitoxxx.github.io/2023/04/tree/"},{"categories":["data structure"],"content":"Root 在 Tree 中， Root 是第一個 Node ，它是 Tree 的 Initial Node ，如上圖 A 為 Root 。 ","date":"2023-04-24","objectID":"https://xxxVitoxxx.github.io/2023/04/tree/:2:3","tags":["tree","data structure"],"title":"Tree","uri":"https://xxxVitoxxx.github.io/2023/04/tree/"},{"categories":["data structure"],"content":"Parent A 通過 Outgoing Edge 連接到 B 和 C ，所以 A 為 B 和 C 的 Parent 。 ","date":"2023-04-24","objectID":"https://xxxVitoxxx.github.io/2023/04/tree/:2:4","tags":["tree","data structure"],"title":"Tree","uri":"https://xxxVitoxxx.github.io/2023/04/tree/"},{"categories":["data structure"],"content":"Child A 通過 Outgoing Edge 連接到 B 和 C ，所以 B 和 C 為 A 的 Child 。 ","date":"2023-04-24","objectID":"https://xxxVitoxxx.github.io/2023/04/tree/:2:5","tags":["tree","data structure"],"title":"Tree","uri":"https://xxxVitoxxx.github.io/2023/04/tree/"},{"categories":["data structure"],"content":"Siblings 擁有相同 Parent 的 Node 稱為 Siblings ，如上圖 D 、 E 稱為 Siblings 。 ","date":"2023-04-24","objectID":"https://xxxVitoxxx.github.io/2023/04/tree/:2:6","tags":["tree","data structure"],"title":"Tree","uri":"https://xxxVitoxxx.github.io/2023/04/tree/"},{"categories":["data structure"],"content":"Ancestor of a Node 從 Root 透過 Edge 到該 Node 中的任何 Node 都稱為該 Node 的祖先，如上圖， D 的祖先有 B 和 A 。 ","date":"2023-04-24","objectID":"https://xxxVitoxxx.github.io/2023/04/tree/:2:7","tags":["tree","data structure"],"title":"Tree","uri":"https://xxxVitoxxx.github.io/2023/04/tree/"},{"categories":["data structure"],"content":"Descendant 該 Node 透過 Outgoing 到 Leaf Node 中的所有 Node 稱為該 Node 的 Descendant ，如上圖。 I 、 M 、 N 為 E 的後裔。 ","date":"2023-04-24","objectID":"https://xxxVitoxxx.github.io/2023/04/tree/:2:8","tags":["tree","data structure"],"title":"Tree","uri":"https://xxxVitoxxx.github.io/2023/04/tree/"},{"categories":["data structure"],"content":"Neighbor of a Node 該 Node 的 Parent 與 Child 都稱為該 Node 的鄰居，如上圖， D 的鄰居有 B 和 H 。 ","date":"2023-04-24","objectID":"https://xxxVitoxxx.github.io/2023/04/tree/:2:9","tags":["tree","data structure"],"title":"Tree","uri":"https://xxxVitoxxx.github.io/2023/04/tree/"},{"categories":["data structure"],"content":"Leaf 沒有任何 Child 的 Node ，也被稱為 External Node ，如上圖 K 、 L 、 M 、 N 、 O 、 P 為 Leaf 。 ","date":"2023-04-24","objectID":"https://xxxVitoxxx.github.io/2023/04/tree/:2:10","tags":["tree","data structure"],"title":"Tree","uri":"https://xxxVitoxxx.github.io/2023/04/tree/"},{"categories":["data structure"],"content":"Subtree Node 與其 Descendant 組成的 Tree 。 ","date":"2023-04-24","objectID":"https://xxxVitoxxx.github.io/2023/04/tree/:2:11","tags":["tree","data structure"],"title":"Tree","uri":"https://xxxVitoxxx.github.io/2023/04/tree/"},{"categories":["data structure"],"content":"Level 從 Root 到 Node 的 Edge 數稱為 Level ，如上圖 I 的 Level 為 3 。 ","date":"2023-04-24","objectID":"https://xxxVitoxxx.github.io/2023/04/tree/:2:12","tags":["tree","data structure"],"title":"Tree","uri":"https://xxxVitoxxx.github.io/2023/04/tree/"},{"categories":["data structure"],"content":"Properties of a Tree ","date":"2023-04-24","objectID":"https://xxxVitoxxx.github.io/2023/04/tree/:3:0","tags":["tree","data structure"],"title":"Tree","uri":"https://xxxVitoxxx.github.io/2023/04/tree/"},{"categories":["data structure"],"content":"Number of Edges Node 到 Node 間只有一條 Edge ，如果 Tree 有 n 個 Node ，那它就有 n-1 條 Edge 。 ","date":"2023-04-24","objectID":"https://xxxVitoxxx.github.io/2023/04/tree/:3:1","tags":["tree","data structure"],"title":"Tree","uri":"https://xxxVitoxxx.github.io/2023/04/tree/"},{"categories":["data structure"],"content":"Depth of a Node Root 到 Node 的 Edge 數，如 B 的 Degree 為 1 ， I 的 Degree 為 3 。 ","date":"2023-04-24","objectID":"https://xxxVitoxxx.github.io/2023/04/tree/:3:2","tags":["tree","data structure"],"title":"Tree","uri":"https://xxxVitoxxx.github.io/2023/04/tree/"},{"categories":["data structure"],"content":"Height of a Tree Root 到 Leaf 的最大 Edge ，如上圖，樹高為 4 。 ","date":"2023-04-24","objectID":"https://xxxVitoxxx.github.io/2023/04/tree/:3:3","tags":["tree","data structure"],"title":"Tree","uri":"https://xxxVitoxxx.github.io/2023/04/tree/"},{"categories":["data structure"],"content":"Height of a Node Node 到 Leaf 的最大 Edge ，如上圖 C 的 Height 為 3 。 ","date":"2023-04-24","objectID":"https://xxxVitoxxx.github.io/2023/04/tree/:3:4","tags":["tree","data structure"],"title":"Tree","uri":"https://xxxVitoxxx.github.io/2023/04/tree/"},{"categories":["data structure"],"content":"Degree of a Node Node 擁有的 Child Node 數量稱為 Node 的 Degree ，如上圖 A 有 B 、 C 兩個 Child Node ，所以 A 的 Degree 為 2 ;而 L 為 Leaf Node 所以 L 的 Degree 為 0 。 ","date":"2023-04-24","objectID":"https://xxxVitoxxx.github.io/2023/04/tree/:3:5","tags":["tree","data structure"],"title":"Tree","uri":"https://xxxVitoxxx.github.io/2023/04/tree/"},{"categories":["data structure"],"content":"Degree of a Tree 樹中 Node 最大的 Degree，如上圖 A 、 B 、 H 、 I 、 C 、 J 的 Degree 都是 2 ，為該樹 Node 最大的 Degree ，所以該樹的 Degree 為 2 。 ","date":"2023-04-24","objectID":"https://xxxVitoxxx.github.io/2023/04/tree/:3:6","tags":["tree","data structure"],"title":"Tree","uri":"https://xxxVitoxxx.github.io/2023/04/tree/"},{"categories":["data structure"],"content":"Types of Tree in Data Structure Tree 有非常多種類型，以下會簡單介紹幾種 Tree 的特性。 ","date":"2023-04-24","objectID":"https://xxxVitoxxx.github.io/2023/04/tree/:4:0","tags":["tree","data structure"],"title":"Tree","uri":"https://xxxVitoxxx.github.io/2023/04/tree/"},{"categories":["data structure"],"content":"General Tree 圖片來源 https://www.simplilearn.com/tutorials/data-structure-tutorial/trees-in-data-structure 一般樹是一種對層次結構沒有限制的樹。 Properties Node 間的資料是無序的 可以有多個 Child ，因此， Root 就像其他 Subtree 的超集 ","date":"2023-04-24","objectID":"https://xxxVitoxxx.github.io/2023/04/tree/:4:1","tags":["tree","data structure"],"title":"Tree","uri":"https://xxxVitoxxx.github.io/2023/04/tree/"},{"categories":["data structure"],"content":"Binary Tree 圖片來源 https://www.simplilearn.com/tutorials/data-structure-tutorial/trees-in-data-structure 二元樹 Properites 每個 Node 只能有 0~2 個 Child ，分別稱為 Left Node 和 Right Node ","date":"2023-04-24","objectID":"https://xxxVitoxxx.github.io/2023/04/tree/:4:2","tags":["tree","data structure"],"title":"Tree","uri":"https://xxxVitoxxx.github.io/2023/04/tree/"},{"categories":["data structure"],"content":"Binary Search Tree 圖片來源 https://www.simplilearn.com/tutorials/data-structure-tutorial/trees-in-data-structure 二元搜尋樹（BST）也是二元樹的一種，它擁有二元樹的所有屬性，但基於某些額外特性，使得二元搜尋樹來的相對高效。 Properties 遵循二元樹的所有特性 所有 Node 的資料不會重複 Right Node 必定大於 Parent 且 Parent 必定大於 Left Node Advantages of BST 與二元樹相比較為高效，因為執行各種操作的時間複雜度較低 由於 Node 的資料是有序的，所以搜尋變得更簡單 因為有序的特性，要查詢某範圍資料的 Node 時使得較為簡單 Disadvantages of BST 圖片來源 https://runestone.academy/ns/books/published/pythonds/Trees/SearchTreeAnalysis.html 為了解決過度傾斜的問題，而有了自平衡二元搜尋樹。 ","date":"2023-04-24","objectID":"https://xxxVitoxxx.github.io/2023/04/tree/:4:3","tags":["tree","data structure"],"title":"Tree","uri":"https://xxxVitoxxx.github.io/2023/04/tree/"},{"categories":["data structure"],"content":"Self-Balanced Binary Search Tree 自平衡二元搜尋樹可以避免二元搜尋樹出現過度傾斜的狀況。 Properties 假設 m 是 Left Subtree 的高度， n 是 Right Subtree 的高度，其 m-n 需等於 1 、 0 或是 -1 一但 m-n 相差超過 1 ，它們會自我平衡，使左右子樹高度不會相差大於 1 Types of Self-Balanced Binary Search Tree 屬於自平衡二元搜尋樹還有以下幾種類型。 AVL Tree Red Black Tree B Tree B+ Tree Splay Tree Priority Search Tree ","date":"2023-04-24","objectID":"https://xxxVitoxxx.github.io/2023/04/tree/:4:4","tags":["tree","data structure"],"title":"Tree","uri":"https://xxxVitoxxx.github.io/2023/04/tree/"},{"categories":["data structure"],"content":"Reference 7.3. Vocabulary and Definitions Data Structure and Algorithms - Tree Data structures: Introduction to Trees - youtube An Introduction to Tree in Data Structure ","date":"2023-04-24","objectID":"https://xxxVitoxxx.github.io/2023/04/tree/:5:0","tags":["tree","data structure"],"title":"Tree","uri":"https://xxxVitoxxx.github.io/2023/04/tree/"},{"categories":["data structure"],"content":"Linked List 是一種線性數據結構，由多個 Node 組成，每個 Node 中包含的 Point 會指向下一個 Node ，藉此將多個 Node 連結起來，適合用來處理動態數據。 其他資料結構如 Tree 和 Graph 都是基於 Linked List 組成的，所以瞭解 Node 與 Linked List 之間的關係及應用，這有助於你未來在學習 Tree 與 Graphs 時會更加輕鬆。 ","date":"2023-03-22","objectID":"https://xxxVitoxxx.github.io/2023/03/linked_list/:0:0","tags":["linked list","data structure"],"title":"Linked List","uri":"https://xxxVitoxxx.github.io/2023/03/linked_list/"},{"categories":["data structure"],"content":"What is a Linked List? Linked List 是一種線性數據結構，它可以動態的存儲數據元素 Node 代表數據元素及指針，其中指針會鏈接下一個 Node ，以此形成一個鏈狀結構 同個 Linked List 中的 Node 資料的型態可以不同 最後一個 Node 的指針會指向 NULL 不會浪費內存空間 ","date":"2023-03-22","objectID":"https://xxxVitoxxx.github.io/2023/03/linked_list/:1:0","tags":["linked list","data structure"],"title":"Linked List","uri":"https://xxxVitoxxx.github.io/2023/03/linked_list/"},{"categories":["data structure"],"content":"Basic Operations Linked List 具有以下操作。 Insertion − Adds an element at the beginning of the list Deletion − Deletes an element at the beginning of the list Insert Last − Adds an element at the end of the list Delete Last − Deletes an element from the end of the list Insert After − Adds an element after an item of the list Delete − Deletes an element from the list using the key Display forward − Displays the complete list in a forward manner Display backward − Displays the complete list in a backward manner ","date":"2023-03-22","objectID":"https://xxxVitoxxx.github.io/2023/03/linked_list/:2:0","tags":["linked list","data structure"],"title":"Linked List","uri":"https://xxxVitoxxx.github.io/2023/03/linked_list/"},{"categories":["data structure"],"content":"Linked List and Array Difference Linked List 和 Array 都屬於線性資料結構，但兩者的使用時機與操作的時間複雜度稍微不太一樣，在選擇要使用哪種 list 前可以依使用情境或會頻繁使用的操作去做取捨。 ","date":"2023-03-22","objectID":"https://xxxVitoxxx.github.io/2023/03/linked_list/:3:0","tags":["linked list","data structure"],"title":"Linked List","uri":"https://xxxVitoxxx.github.io/2023/03/linked_list/"},{"categories":["data structure"],"content":"Array 會分配一段連續記憶體位置來儲存，一般來說 Array 的長度是固定的且資料型態都要相同，以 go 來說，當你宣告 Array 時，同時也需宣告 Array 的長度，所以不管有無使用都會分配記憶體空間給它。 arr := [3]int{} 可以透過 index 直接取得特定資料，查詢速度較快。 When to Use 需要快速取得資料時 不需要頻繁新增和刪除資料時 資料的數量不會有太大的變更 ","date":"2023-03-22","objectID":"https://xxxVitoxxx.github.io/2023/03/linked_list/:3:1","tags":["linked list","data structure"],"title":"Linked List","uri":"https://xxxVitoxxx.github.io/2023/03/linked_list/"},{"categories":["data structure"],"content":"Linked List 將多個 Node 有順序性的關聯起來，不需要連續的記憶體空間，資料數量可以是動態的，因此不需要預留空間，不會有 resize 問題。 When to Use 無法預期資料數量時 需要頻繁新增和刪除資料時 不需要頻繁查詢資料時 ","date":"2023-03-22","objectID":"https://xxxVitoxxx.github.io/2023/03/linked_list/:3:2","tags":["linked list","data structure"],"title":"Linked List","uri":"https://xxxVitoxxx.github.io/2023/03/linked_list/"},{"categories":["data structure"],"content":"Types of Linked List in Data Structure Linked List 可以分為以下四種類型。 ","date":"2023-03-22","objectID":"https://xxxVitoxxx.github.io/2023/03/linked_list/:4:0","tags":["linked list","data structure"],"title":"Linked List","uri":"https://xxxVitoxxx.github.io/2023/03/linked_list/"},{"categories":["data structure"],"content":"Singly Linked List 單鏈表是最常見的類型，每個節點都包含數據跟指向下一個 Node 的指針位置（通常會用 next 表示）。 程式碼範例 ","date":"2023-03-22","objectID":"https://xxxVitoxxx.github.io/2023/03/linked_list/:4:1","tags":["linked list","data structure"],"title":"Linked List","uri":"https://xxxVitoxxx.github.io/2023/03/linked_list/"},{"categories":["data structure"],"content":"Doubly Linked List 雙向鏈表中的 Node 會有存儲兩個指針的位置，第一個會儲存上一個 Node 位置（prev），第二個會儲存下一個 Node 位置，因此你可以從任一個 Node 存取上一個 Node 及下一個 Node。 程式碼範例 ","date":"2023-03-22","objectID":"https://xxxVitoxxx.github.io/2023/03/linked_list/:4:2","tags":["linked list","data structure"],"title":"Linked List","uri":"https://xxxVitoxxx.github.io/2023/03/linked_list/"},{"categories":["data structure"],"content":"Circular Singly Linked List 循環鏈表與單鏈表很相似，唯一不同的是，最後一個節點的 next 會指向第一個節點，以此實現循環。 程式碼範例 ","date":"2023-03-22","objectID":"https://xxxVitoxxx.github.io/2023/03/linked_list/:4:3","tags":["linked list","data structure"],"title":"Linked List","uri":"https://xxxVitoxxx.github.io/2023/03/linked_list/"},{"categories":["data structure"],"content":"Circular Doubly Linked List 雙向循環鏈表與雙項鏈表相似，不同的地方在於最後一個節點的 next 會指向第一個節點，而第一個節點的 prev 會指向最後一個節點，以此達到雙向循環。 程式碼範例 ","date":"2023-03-22","objectID":"https://xxxVitoxxx.github.io/2023/03/linked_list/:4:4","tags":["linked list","data structure"],"title":"Linked List","uri":"https://xxxVitoxxx.github.io/2023/03/linked_list/"},{"categories":["data structure"],"content":"Reference Linked List in A Data Structure: All You Need to Know ","date":"2023-03-22","objectID":"https://xxxVitoxxx.github.io/2023/03/linked_list/:5:0","tags":["linked list","data structure"],"title":"Linked List","uri":"https://xxxVitoxxx.github.io/2023/03/linked_list/"},{"categories":["jwt"],"content":"JWT 是 JSON Web Token 的簡寫，它是一種開放標準 RFC 7519，此標準定義了一種緊湊且獨立的方式，用 JSON 物件在雙方之間安全地傳輸信息。 ","date":"2023-02-09","objectID":"https://xxxVitoxxx.github.io/2023/02/jwt/:0:0","tags":["jwt"],"title":"JWT","uri":"https://xxxVitoxxx.github.io/2023/02/jwt/"},{"categories":["jwt"],"content":"什麼是 JWT 簡單來說，它是一個 JSON 格式的加密字串，其中包含的 Secret 允許我們可以驗證不同服務的請求者，是一種在有效時間內，可以利用 token 要求對應操作權限的一種方法。 ","date":"2023-02-09","objectID":"https://xxxVitoxxx.github.io/2023/02/jwt/:1:0","tags":["jwt"],"title":"JWT","uri":"https://xxxVitoxxx.github.io/2023/02/jwt/"},{"categories":["jwt"],"content":"什麼時候會使用 JWT Authorization 這是使用 JWT 最常見的場景，當用戶登入後，服務端會發給用戶 JWT ，往後用戶的請求只要帶著 JWT ，使用戶就可以訪問該 JWT 可以訪問的服務與資源。 Information Exchange 因為 JWT 可以簽章，所以它是雙方之間傳輸資訊的好方法，舉例來說，使用公/私鑰，你可以確認請求者是不是正確的人，此外，由於簽章是使用 Header 與 Payload ，你還可以驗證內容是否被篡改過。 ","date":"2023-02-09","objectID":"https://xxxVitoxxx.github.io/2023/02/jwt/:2:0","tags":["jwt"],"title":"JWT","uri":"https://xxxVitoxxx.github.io/2023/02/jwt/"},{"categories":["jwt"],"content":"JWT 結構 JWT 是由三個部位並用 . 組成的，分別是： Header Payload Signature 完整的 JWT 如下： ","date":"2023-02-09","objectID":"https://xxxVitoxxx.github.io/2023/02/jwt/:3:0","tags":["jwt"],"title":"JWT","uri":"https://xxxVitoxxx.github.io/2023/02/jwt/"},{"categories":["jwt"],"content":"Header Header 由兩個部分組成，分別是 token 的型態（也就是 JWT）跟使用的簽章演算法 例如： { \"typ\": \"JWT\", \"alg\": \"HS256\" } 這個 json 會以 Base64Url 編碼成 JWT 的第一個部位（xxxxx） ","date":"2023-02-09","objectID":"https://xxxVitoxxx.github.io/2023/02/jwt/:3:1","tags":["jwt"],"title":"JWT","uri":"https://xxxVitoxxx.github.io/2023/02/jwt/"},{"categories":["jwt"],"content":"Payload Payload 包含 Claims ， Claims 是關於實體（通常是用戶）和附加數據的聲明， Claims 有三種類型： registered, public and private claims 。 Registered Claims 它是一組由 RFC 7519 定義的聲明，沒有強制性要使用，但建議使用，可以提供一組有用的、可互相操作的聲明，例如： iss, exp, sub, aud 。 Public Claims 由 RFC 7519 以外的人定義的聲明，且被公開在 IANA JSON Web Token Registry ，例如： preferred_username 。 Private Claims 供 JWT 發行者與用戶雙方使用的自定義聲明，既不是 registered 也不是 public claims，這意味著在你的應用程式之外，該聲明可能無法被正確的理解，因為別的應用程式可能沒有使用相同名稱的聲明或使用聲明的方法與你不同。 一個 Payload 範例如： { \"sub\": \"1234567890\", \"name\": \"vito\", \"exp\": 15323232, // the expiration time on or after which the JWT must not be accepted for processing \"iat\": 14567766 // when the token was issues } Payload 會透過 Base64Url 編碼成 JWT 的第二個部位（yyyyy）。 請注意，對於已簽章的 token ，雖然受到防止篡改的保護，但它是任何人都可以解讀的，所以請不要將敏感信息（密碼），放在 Header 或 Payload ，除非它是加密過的。 ","date":"2023-02-09","objectID":"https://xxxVitoxxx.github.io/2023/02/jwt/:3:2","tags":["jwt"],"title":"JWT","uri":"https://xxxVitoxxx.github.io/2023/02/jwt/"},{"categories":["jwt"],"content":"Signature 為了創建 Signature ，必須採用已編碼過的 Header 、已編碼過的 Payload 、 Secret 、 Header 指定的演算法並將其進行簽章。 例如，使用 HMAC SHA256 算法，會依照以下方式創建 Signature（zzzzz） HMACSHA256( base64UrlEncode(header) + \".\" + base64UrlEncode(payload), secret ) Signature 用於驗證信息沒有被篡改過，對於使用私鑰簽章的 token ，它還可以驗證 JWT 的請求者 ","date":"2023-02-09","objectID":"https://xxxVitoxxx.github.io/2023/02/jwt/:3:3","tags":["jwt"],"title":"JWT","uri":"https://xxxVitoxxx.github.io/2023/02/jwt/"},{"categories":["jwt"],"content":"組合成 JWT 結構 由已用 Base64Url 編譯過的 Header 、 Payload 、 Signature ，三個 Base64-URL 字串組合而成，可以很容易的在 HTML 和 HTTP 環境中傳遞，與基於 XML 標準（如 SAML） 相比更加緊湊。 下面展示一個 JWT ，他對前面的 Header 、 Payload 進行編碼，並使用 secret 進行簽名 eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9. eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6InZpdG8iLCJleHAiOjE1MzIzMjMyLCJpYXQiOjE0NTY3NzY2fQ. 4FgwaKyx5eGFkJUoEVD_Po5p9jjjWOcl4YnjpDBwZPs 你可以使用 JWT Debugger 驗證、解碼和生成 JWT ","date":"2023-02-09","objectID":"https://xxxVitoxxx.github.io/2023/02/jwt/:3:4","tags":["jwt"],"title":"JWT","uri":"https://xxxVitoxxx.github.io/2023/02/jwt/"},{"categories":["jwt"],"content":"JWT 如何運作 在身份驗證中，會如下圖所示，當用戶成功登入後，會回傳一個 JSON Web Token ，之後在有限時間內，可以使用 token 做特定的操作或請求，不需重複執行登入的動作，由於 token 是憑證，因此必須注意防止出現安全問題，通常不應保留過期的 token 用戶使用帳號密碼登入 驗證用戶帳號密碼的正確性 回覆驗證結果 如果驗證成功會產生 signature 得到 JWT 如果驗證成功，用戶會得到 JWT 每當用戶想訪問受保護的路由或資源時，用戶都應發送 JWT ，因為 JWT 不記名的關係，所以通常會在驗證的 header 中使用 Bearer 模式（如果利用 Authorization header 傳送 token ，就不會有 CORS 問題，因為它不使用 cookie），內容如下： Authorization: Bearer \u003ctoken\u003e 由於缺乏安全性，不應該將敏感資訊儲存在瀏覽器中 ","date":"2023-02-09","objectID":"https://xxxVitoxxx.github.io/2023/02/jwt/:4:0","tags":["jwt"],"title":"JWT","uri":"https://xxxVitoxxx.github.io/2023/02/jwt/"},{"categories":["jwt"],"content":"用 Go 實作 JWT 身份驗證 ","date":"2023-02-09","objectID":"https://xxxVitoxxx.github.io/2023/02/jwt/:5:0","tags":["jwt"],"title":"JWT","uri":"https://xxxVitoxxx.github.io/2023/02/jwt/"},{"categories":["jwt"],"content":"產生 JWT 當用戶成功登入後，會透過 generateJWTToken() 產生 JWT 。 type JWTClaims struct { Email string `json:\"email\"` jwt.RegisteredClaims } func generateJWTToken(username string) (string, error) { token := jwt.NewWithClaims(jwt.SigningMethodHS256, JWTClaims{ Email: \"xxxVitoxxx@gmail.com\", RegisteredClaims: jwt.RegisteredClaims{ NotBefore: jwt.NewNumericDate(time.Now()), IssuedAt: jwt.NewNumericDate(time.Now()), ExpiresAt: jwt.NewNumericDate(time.Now().Add(1 * time.Minute)), }, }) return token.SignedString(Secret) } 第 1 行： 宣告你定義的 Claims 。 第 7 行： 先用指定的簽章演算法和定義的 Cliams 去建立 token 。 第 10~12 行： 定義要使用的 Registered Claims 。 第 15 行： 將 token 進行簽章，並回傳 JWT 。 ","date":"2023-02-09","objectID":"https://xxxVitoxxx.github.io/2023/02/jwt/:5:1","tags":["jwt"],"title":"JWT","uri":"https://xxxVitoxxx.github.io/2023/02/jwt/"},{"categories":["jwt"],"content":"驗證 JWT 這邊將驗證 JWT 的方法寫成 middleware ，讓需有 JWT 權限才能訪問的 API 會先經過該 middleware 驗證 JWT ，驗證成功後才能獲取 API 資源。 func middlewareVerifyJWT() gin.HandlerFunc { return func(c *gin.Context) { auth := c.GetHeader(\"Authorization\") if auth == \"\" { c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{\"message\": \"missing authorization\"}) return } bearer := strings.Split(auth, \" \") if bearer[0] != \"Bearer\" || len(bearer) != 2 || len(bearer[1]) == 0 { c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{\"message\": \"invalid authorization\"}) return } tokenDecode, err := jwt.ParseWithClaims(bearer[1], \u0026JWTClaims{}, func(token *jwt.Token) (interface{}, error) { return Secret, nil }) if err != nil { c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{\"message\": \"invalid token\"}) return } _, ok := tokenDecode.Claims.(*JWTClaims) if !ok || !tokenDecode.Valid { c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{\"message\": \"invalid token\"}) return } c.Next() } } 第 3~7 行： 從 request 的 header 取得 Authorization 的資料，並檢查 Authorization 是否有資料。 第 9~13 行： 檢查是否為 Bearer token ，且 token 是否有資料。 第 15~21 行： 透過自定義的 Claims 對 token 進行解析，並確認解析是否有錯誤。 第 23~27 行： 驗證 tokenDecode 的 Claims 是否是我們自定義的 JWTClaims 型態，及解析完的 token 是否有效。 完整程式碼 ","date":"2023-02-09","objectID":"https://xxxVitoxxx.github.io/2023/02/jwt/:5:2","tags":["jwt"],"title":"JWT","uri":"https://xxxVitoxxx.github.io/2023/02/jwt/"},{"categories":["jwt"],"content":"Reference jwt.io 搭配上面一起 JWT(JSON Web Token) — 原理介紹 淺談JWT的安全性與適用情境 ","date":"2023-02-09","objectID":"https://xxxVitoxxx.github.io/2023/02/jwt/:6:0","tags":["jwt"],"title":"JWT","uri":"https://xxxVitoxxx.github.io/2023/02/jwt/"},{"categories":["data structure"],"content":"queue 是一種兩端開放的線性數據結構，在前端取出元素，在尾端新增元素，類似排隊購票，排在第一位的，可以最先購票。 遵循先進先出（FILO, First-in-First-out）的特性，通常被使用在管理多線程和實現優先級排隊系統。 ","date":"2023-01-12","objectID":"https://xxxVitoxxx.github.io/2023/01/queue/:0:0","tags":["queue","data structure"],"title":"Queue","uri":"https://xxxVitoxxx.github.io/2023/01/queue/"},{"categories":["data structure"],"content":"Queue 的基本操作 基本操作： Enqueue: 新增元素到 queue 尾端 Dequeue: 移除 queue 前端元素 Peek: 取得 queue 前端元素 輔助操作： IsEmpty: 檢查 queue 是否為空 IsFull: 檢查 queue 是否被填滿 ","date":"2023-01-12","objectID":"https://xxxVitoxxx.github.io/2023/01/queue/:1:0","tags":["queue","data structure"],"title":"Queue","uri":"https://xxxVitoxxx.github.io/2023/01/queue/"},{"categories":["data structure"],"content":"Implement of the stack in golang queue 可以使用 array 和 linked List 實作，這邊使用 golang 的 slice 實作有容量的 Queue ，完整內容可以參考這裡， 想參考 linked list 實作可以參考這邊。 ","date":"2023-01-12","objectID":"https://xxxVitoxxx.github.io/2023/01/queue/:2:0","tags":["queue","data structure"],"title":"Queue","uri":"https://xxxVitoxxx.github.io/2023/01/queue/"},{"categories":["data structure"],"content":"Declaring stack type Queue struct { queue []int capacity int } func NewQueue(cap int) *Queue { return \u0026Queue{capacity: cap} } Queue 結構有兩個屬性： queue: int 屬性的 slice capacity: queue 的大小 ","date":"2023-01-12","objectID":"https://xxxVitoxxx.github.io/2023/01/queue/:2:1","tags":["queue","data structure"],"title":"Queue","uri":"https://xxxVitoxxx.github.io/2023/01/queue/"},{"categories":["data structure"],"content":"Implementing a IsEmpty operation func (q *Queue) IsEmpty() bool { return len(q.queue) == 0 } ","date":"2023-01-12","objectID":"https://xxxVitoxxx.github.io/2023/01/queue/:2:2","tags":["queue","data structure"],"title":"Queue","uri":"https://xxxVitoxxx.github.io/2023/01/queue/"},{"categories":["data structure"],"content":"Implementing a IsFull operation func (q *Queue) IsFull() bool { return len(q.queue) == q.capacity } ","date":"2023-01-12","objectID":"https://xxxVitoxxx.github.io/2023/01/queue/:2:3","tags":["queue","data structure"],"title":"Queue","uri":"https://xxxVitoxxx.github.io/2023/01/queue/"},{"categories":["data structure"],"content":"Implementing a Enqueue operation func (q *Queue) Enqueue(element int) error { if q.IsFull() { return errors.New(\"queue overflow\") } q.queue = append(q.queue, element) return nil } ","date":"2023-01-12","objectID":"https://xxxVitoxxx.github.io/2023/01/queue/:2:4","tags":["queue","data structure"],"title":"Queue","uri":"https://xxxVitoxxx.github.io/2023/01/queue/"},{"categories":["data structure"],"content":"Implementing a Dequeue operation func (q *Queue) Dequeue() error { if q.IsEmpty() { return errors.New(\"queue underflow\") } q.queue = q.queue[1:] return nil } ","date":"2023-01-12","objectID":"https://xxxVitoxxx.github.io/2023/01/queue/:2:5","tags":["queue","data structure"],"title":"Queue","uri":"https://xxxVitoxxx.github.io/2023/01/queue/"},{"categories":["data structure"],"content":"Implementing a Peek operation func (q *Queue) Peek() (int, error) { if len(q.queue) == 0 { return 0, errors.New(\"empty queue\") } return q.queue[0], nil } ","date":"2023-01-12","objectID":"https://xxxVitoxxx.github.io/2023/01/queue/:2:6","tags":["queue","data structure"],"title":"Queue","uri":"https://xxxVitoxxx.github.io/2023/01/queue/"},{"categories":["data structure"],"content":"Reference Queue Data Structure Queue Data Structure: Types, Implementation, Applications ","date":"2023-01-12","objectID":"https://xxxVitoxxx.github.io/2023/01/queue/:3:0","tags":["queue","data structure"],"title":"Queue","uri":"https://xxxVitoxxx.github.io/2023/01/queue/"},{"categories":["data structure"],"content":"stack 是一種線性的資料結構，其新增資料或刪除資料都在同一端，這意味著，若你想刪除第一筆資料，就得先從最後一筆資料開始依序刪除。 遵循後進先出（LIFO, Last-in-First-out）或先進後出（FILO, First-in-Last-out）原則，像疊盤子，假設一次只能拿一個盤子，若你想疊盤子，就只能疊在最上面;若想拿到最下面的盤子，就得先從最上面的盤子開始一個一個拿走。 因 stack 特性，需實作以下幾種基本操作： Push: 新增資料到 stack 的頂端（top） Pop: 移除 stack 中頂端（top）的資料 Peek: 取得頂端（top）的資料 並實作以下幾種操作輔助： IsEmpty: 檢查 stack 是否為空 IsFull: 檢查 stack 是否被填滿（當 stack 是有長度限制才需要實作） Size: stack 大小 Print: 印出 stack 資料 Push operation 這是在 stack 實現 Push 操作的圖形說明，它展示了當資料被新增到 stack 時， stack 如何由左至右增長。 Pop operation 這是在 stack 實現 Pop 操作的圖形說明，它展示了當資料從 stack 被移除時， stack 如何由左至右減少。 ","date":"2022-11-29","objectID":"https://xxxVitoxxx.github.io/2022/11/stack/:0:0","tags":["stack","data structure"],"title":"Stack","uri":"https://xxxVitoxxx.github.io/2022/11/stack/"},{"categories":["data structure"],"content":"Implement of the stack in golang 可以用 slice 與 linked list 實作 stack，這邊用 slice 示範如何實作。 ","date":"2022-11-29","objectID":"https://xxxVitoxxx.github.io/2022/11/stack/:1:0","tags":["stack","data structure"],"title":"Stack","uri":"https://xxxVitoxxx.github.io/2022/11/stack/"},{"categories":["data structure"],"content":"slice based stack Declaring stack type StackSlice struct { top int capacity int stack []int } func NewStackSlice(capacity int) *StackSlice { return \u0026StackSlice{ top: -1, capacity: capacity, stack: make([]int, 0, capacity), } } stack 結構有以下三種屬性： top: stack 中最後一筆資料的位置（當沒有資料時; top 為 -1） capacity: stack 的大小 stack: int 屬性的 slice Implementing a IsEmpty operation 檢查 stack 是否有資料。 func (s *StackSlice) IsEmpty() bool { return s.top == -1 } Implementing a IsFull operation 檢查 stack 是否還有空間可以存放資料。 func (s *StackSlice) IsFull() bool { return s.top+1 == s.capacity } Implementing a Size operation 回傳 stack 大小。 func (s *StackSlice) Size() int { return s.top + 1 } Implementing a Peek operation 回傳 stack 最後一筆資料。 func (s *StackSlice) Peek() (int, error) { if s.IsEmpty() { return 0, errors.New(\"stack underflow\") } return s.stack[s.top], nil } Implementing a Print operation 印出 stack 中所有資料。 func (s *StackSlice) Print() { for i := 0; i \u003c= s.top; i++ { fmt.Printf(\"%d \", s.stack[i]) } fmt.Println() } Implementing a Push operation 新增資料到 stack func (s *StackSlice) Push(data int) error { if s.IsFull() { return errors.New(\"stack overflow\") } s.top++ s.stack[s.top] = data return nil } Push 實現的方法如下所述： 第 2 行： 先檢查 stack 是否還有空間可以存放資料。 第 6 行： 調整 top 位置 第 7 行： 將資料指定到 top 位置 Implementing a Pop operation 從 stack 移除資料 func (s *StackSlice) Pop() error { if s.IsEmpty() { return errors.New(\"stack underflow\") } s.stack = s.stack[:s.top] s.top-- return nil } Pop 實現的方法如下所述： 第 2 行： 檢查 stack 是否有資料 第 6 行： 從 slice 移除 top 的資料 第 7 行： 調整 top 位置 ","date":"2022-11-29","objectID":"https://xxxVitoxxx.github.io/2022/11/stack/:1:1","tags":["stack","data structure"],"title":"Stack","uri":"https://xxxVitoxxx.github.io/2022/11/stack/"},{"categories":["data structure"],"content":"application of stack in data structure 這邊舉例幾個 stack 的應用 Parentheses Checking Expression Evaluation and Conversion Backtracking String Reversal Towers of Hanoi ","date":"2022-11-29","objectID":"https://xxxVitoxxx.github.io/2022/11/stack/:2:0","tags":["stack","data structure"],"title":"Stack","uri":"https://xxxVitoxxx.github.io/2022/11/stack/"},{"categories":["data structure"],"content":"1. Parentheses Checking 檢查 () 、 [] 、 {} 括號在是否有效，同時檢查左右括號是否是平衡的。 例如 [(){}] 是平衡的，而 {[}] 是不平衡的。 ","date":"2022-11-29","objectID":"https://xxxVitoxxx.github.io/2022/11/stack/:2:1","tags":["stack","data structure"],"title":"Stack","uri":"https://xxxVitoxxx.github.io/2022/11/stack/"},{"categories":["data structure"],"content":"2. Expression Evaluation and Conversion 表達式的評估（計算）與轉換，表達式有以下三種型態： Prefix Expression（前輟表達式） 又稱波蘭表達式，其特點是沒有括號且運算符號在數字前面。 X +XY *+XY-XY Infix Expression（中輟表達式） 一般人們可以識別、計算的運算式。 X X+Y (X+Y)*(X-Y) Postfix Expression（後輟表達式） 又稱逆波蘭表達式，其特點是沒有括號且運算符號在數字後面。 X XY+ XY+XY-* Evaluation 表達式的計算是基於運算符（operator）的優先級（precedence）和結合性（associativity），當表達式有多個運算符時，會依據運算符的優先級和結合性做評估，優先級高的運算符先求值，優先級低的最後求值。 30 + 8 * 3 / 2 在上面的中輟表達式中，* 和 / 的優先級相同，而 + 的優先級最低，根據運算符號的優先級，會先計算 * 和 / ，再做 + ，由於 * 和 / 有相同優先級，根據 golang operator associativity 計算順序會先執行 * ，再執行 / ，最後才執行 + ，因此上面的表達式的求值順序如下： 8 * 3 ---\u003e 24 24 / 2 ---\u003e 12 30 + 12 ---\u003e 42 Conversion 由於需要額外處理優先級，因此計算機很難評估中輟表達式，中輟表達式是人類編寫和識別的方式，通常也是程式的輸入方式，因此通常會將中輟主換成前輟或後輟。 ","date":"2022-11-29","objectID":"https://xxxVitoxxx.github.io/2022/11/stack/:2:2","tags":["stack","data structure"],"title":"Stack","uri":"https://xxxVitoxxx.github.io/2022/11/stack/"},{"categories":["data structure"],"content":"3. Backtracking Backtracking 是一種窮舉的搜尋法，會找尋所有可能的答案，可分為兩個概念； enumerate： 列出可能的答案在測試答案是否正確 pruning： 在找尋答案的過程中，只要遇到不符合的條件就回朔到上一步，不在繼續往下尋找 8 queens problem 如何在 8 x 8 的西洋棋盤上放 8 個皇后的棋子，且這 8 個皇后不會互相攻擊（也就是每個皇后的橫向、縱向、斜對角都沒有出現其他皇后）的所有解法。 Sudoku 數獨，是一種數學邏輯遊戲，你必須用 1 到 9 去填滿 9 x 9 的格子，且各數字的橫向、縱向皆不會出現重複的數字。 ","date":"2022-11-29","objectID":"https://xxxVitoxxx.github.io/2022/11/stack/:2:3","tags":["stack","data structure"],"title":"Stack","uri":"https://xxxVitoxxx.github.io/2022/11/stack/"},{"categories":["data structure"],"content":"4. String Reversal 利用 stack 先進後出的特性，反轉字串。 ","date":"2022-11-29","objectID":"https://xxxVitoxxx.github.io/2022/11/stack/:2:4","tags":["stack","data structure"],"title":"Stack","uri":"https://xxxVitoxxx.github.io/2022/11/stack/"},{"categories":["data structure"],"content":"5. Towers of Hanoi 河內塔是根據傳說形成的數學問題，有三根桿子分別是 A、B、C ，有 N 個圓盤疊在桿子 A 上，且這 N 個圓盤的尺寸由下到上依序變小，需在遵循以下條件的同時將所有圓盤移至桿子 C : 同一時間只能移動一個圓盤 小圓盤必須在大圓盤上 ","date":"2022-11-29","objectID":"https://xxxVitoxxx.github.io/2022/11/stack/:2:5","tags":["stack","data structure"],"title":"Stack","uri":"https://xxxVitoxxx.github.io/2022/11/stack/"},{"categories":["data structure"],"content":"Reference Data Structure and Algorithms - Stack Stack: Intro(簡介) Implementing Stacks in Data Structures Slice Based Stack Implementation in Golang ","date":"2022-11-29","objectID":"https://xxxVitoxxx.github.io/2022/11/stack/:3:0","tags":["stack","data structure"],"title":"Stack","uri":"https://xxxVitoxxx.github.io/2022/11/stack/"},{"categories":["instagram"],"content":"因 Meta Develop 開發政策，強制所有的用戶端 OAuth 都要使用 https 的 URL 才能被 Meta 認定為有效的 OAuth 重新導向 URL ，這會導致我們在地端測試時，會需要 https 的 URL 供我們做測試，這邊我們使用 ngrok 來產生一組 https 的 URL ，並帶著各位如何在地端使用 ngrok 來測試 instagram basic api ","date":"2022-08-09","objectID":"https://xxxVitoxxx.github.io/2022/08/instagram-basic/:0:0","tags":["instagram"],"title":"testing instagram basic api on localhost","uri":"https://xxxVitoxxx.github.io/2022/08/instagram-basic/"},{"categories":["instagram"],"content":"建立 instagram 的應用程式 ","date":"2022-08-09","objectID":"https://xxxVitoxxx.github.io/2022/08/instagram-basic/:1:0","tags":["instagram"],"title":"testing instagram basic api on localhost","uri":"https://xxxVitoxxx.github.io/2022/08/instagram-basic/"},{"categories":["instagram"],"content":"在 Meta 開發人員工具創建應用程式 到 Meta for Developers 建立應用程式 再來需要選擇應用程式的類型及填寫名稱，這邊需要注意類型的選擇會導致該應用程式可使用的產品、權限及功能，詳情可以參考官方文件 點選 instagram 基本顯示的設定 在 instagram 基本顯示 \u003e 基本顯示 中建立新的應用程式 ","date":"2022-08-09","objectID":"https://xxxVitoxxx.github.io/2022/08/instagram-basic/:1:1","tags":["instagram"],"title":"testing instagram basic api on localhost","uri":"https://xxxVitoxxx.github.io/2022/08/instagram-basic/"},{"categories":["instagram"],"content":"新增 instagram 測試人員 完成上面的步驟後，點選左邊選項中的 角色 \u003e instagram 測試人員的按鈕，輸入你要用來測試的 instagram 帳號 這時登入網頁版的 instagram ，在 設定 \u003e 應用程式和網站 \u003e 測試員邀請 ，會發現應用程式的邀請確認，點選接受就成功成為應用程式的測試人員 ","date":"2022-08-09","objectID":"https://xxxVitoxxx.github.io/2022/08/instagram-basic/:1:2","tags":["instagram"],"title":"testing instagram basic api on localhost","uri":"https://xxxVitoxxx.github.io/2022/08/instagram-basic/"},{"categories":["instagram"],"content":"建立一個 web 服務 這邊以 golang 搭建一個簡單的網頁並把服務放在 80 port package main import ( \"fmt\" \"log\" \"net/http\" ) func main() { http.HandleFunc(\"/ping\", func(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, \"pong\") }) log.Fatal(http.ListenAndServe(\":80\", nil)) } 把服務起起來並確認頁面有正常顯示，以上面範例，在瀏覽器 載入 localhost:80/ping 會出現以下圖例 ","date":"2022-08-09","objectID":"https://xxxVitoxxx.github.io/2022/08/instagram-basic/:2:0","tags":["instagram"],"title":"testing instagram basic api on localhost","uri":"https://xxxVitoxxx.github.io/2022/08/instagram-basic/"},{"categories":["instagram"],"content":"設定 ngrok ","date":"2022-08-09","objectID":"https://xxxVitoxxx.github.io/2022/08/instagram-basic/:3:0","tags":["instagram"],"title":"testing instagram basic api on localhost","uri":"https://xxxVitoxxx.github.io/2022/08/instagram-basic/"},{"categories":["instagram"],"content":"安裝 ngrok 先到 ngrok 官網 下載對應的版本並註冊登入會員，初次安裝需先驗證 ngrok 的 agent，到 Your Authtoken 執行 Command Line 的指令，會將 ngrok 的 Authtoken 保存在你的電腦，授於 agent 使用 ngrok 所有功能的權限 完成後執行 $ ngrok http {port} ，就可以將 localhost:{port} 的服務對外開放，因為我服務使用 80 port 的關係，所以我要執行 $ ngrok http 80 ，接著會看到以下圖片的樣子，就代表成功將地端的 80 port 對外開放，而紅色框框的 https 網址為你地端服務對外的網址，這時其他人就可以透過該網址連到你的網頁 ","date":"2022-08-09","objectID":"https://xxxVitoxxx.github.io/2022/08/instagram-basic/:3:1","tags":["instagram"],"title":"testing instagram basic api on localhost","uri":"https://xxxVitoxxx.github.io/2022/08/instagram-basic/"},{"categories":["instagram"],"content":"設定應用程式 回到 Meta for Developers 左邊選項的 instagram 基本顯示 \u003e 基本顯示 去設定 用戶端 OAuth 設定、取消授權、資料刪除要求，在圖中的三個欄位填入 ngrok 產生的 https 網址 ","date":"2022-08-09","objectID":"https://xxxVitoxxx.github.io/2022/08/instagram-basic/:3:2","tags":["instagram"],"title":"testing instagram basic api on localhost","uri":"https://xxxVitoxxx.github.io/2022/08/instagram-basic/"},{"categories":["instagram"],"content":"取得 instagram basic api 的 token ","date":"2022-08-09","objectID":"https://xxxVitoxxx.github.io/2022/08/instagram-basic/:4:0","tags":["instagram"],"title":"testing instagram basic api on localhost","uri":"https://xxxVitoxxx.github.io/2022/08/instagram-basic/"},{"categories":["instagram"],"content":"驗證測試人員 建構授權的視窗網址，{app-id} 為 instagram 基本顯示 \u003e 基本顯示 \u003e instagram 應用程式編號， {redirect-uri} 為有效的 OAuth 重新導向 URI的網址（網址必須完全相同） https://api.instagram.com/oauth/authorize ?client_id={app-id} \u0026redirect_uri={redirect-uri} \u0026scope=user_profile,user_media \u0026response_type=code 以我們剛剛產生的 https 網址為例 https://api.instagram.com/oauth/authorize ?client_id=135421602932815 \u0026redirect_uri=https://6e02-220-135-89-54.jp.ngrok.io/ping \u0026scope=user_profile,user_media \u0026response_type=code 在瀏覽器載入網址後，會出現應用程式要求權限的說明 點選允許後，會跳轉到你在應用程式設定的重新導向 URI的頁面，這時請觀察該網頁的網址 網址中的 code 到 #_ 之間為測試人員的授權碼 https://6e02-220-135-89-54.jp.ngrok.io/ping?code=AQAODGH_DePavKuPRK0UKy5nMnSBYG_EEjOcodAUC5Q-wVS0uP5SDjFNgNWdw2a4plybIndmH0CuPKvx5k-IDNlVh4sX2qjao1LKGRykYNvpn_6gTtYWYPDrcJR0Lt5JrWHdo5Nj70cBg6VMDeW-vyzEAXzgnfgUTg3FeOfdJ2vlBenmCsMqwCrOS2SSQzMLEGK1B7osZz7W8ckAGkiyYZUGTOTlIDDuy4UOpLJ_PJd_4g#_ ","date":"2022-08-09","objectID":"https://xxxVitoxxx.github.io/2022/08/instagram-basic/:4:1","tags":["instagram"],"title":"testing instagram basic api on localhost","uri":"https://xxxVitoxxx.github.io/2022/08/instagram-basic/"},{"categories":["instagram"],"content":"將授權碼換成 token 將 {app-id} 、 {app-secret} 、 {redirect-uri} 、 {code} 換成你的 instagram 應用程式編號、 instagram 應用程式密鑰 、重新導向 URI 、授權碼，並輸入指令傳送請求 curl -X POST https://api.instagram.com/oauth/access_token \\ -F client_id={app-id} \\ -F client_secret={app-secret} \\ -F grant_type=authorization_code \\ -F redirect_uri={redirect-uri} \\ -F code={code} 成功時，會回傳以下 json 格式 { \"access_token\": \"IGQVJV...\", \"user_id\": 178414005245354752 } 例如： 這時候就可以用 access_token 和 user_id 去串接 instagram basic api 了 ","date":"2022-08-09","objectID":"https://xxxVitoxxx.github.io/2022/08/instagram-basic/:4:2","tags":["instagram"],"title":"testing instagram basic api on localhost","uri":"https://xxxVitoxxx.github.io/2022/08/instagram-basic/"},{"categories":["instagram"],"content":"Reference Meta for Developers 產品開發 | 如何在Localhost實作與測試FB Login SDK功能 ","date":"2022-08-09","objectID":"https://xxxVitoxxx.github.io/2022/08/instagram-basic/:5:0","tags":["instagram"],"title":"testing instagram basic api on localhost","uri":"https://xxxVitoxxx.github.io/2022/08/instagram-basic/"},{"categories":["golang"],"content":"Go 的標準函式庫可以很容易的對 JSON 資料進行編、解碼的工作。 ","date":"2022-06-09","objectID":"https://xxxVitoxxx.github.io/2022/06/golang-json/:0:0","tags":["golang","json"],"title":"用 golang 處理 json 資料","uri":"https://xxxVitoxxx.github.io/2022/06/golang-json/"},{"categories":["golang"],"content":"json 資料轉換 ","date":"2022-06-09","objectID":"https://xxxVitoxxx.github.io/2022/06/golang-json/:1:0","tags":["golang","json"],"title":"用 golang 處理 json 資料","uri":"https://xxxVitoxxx.github.io/2022/06/golang-json/"},{"categories":["golang"],"content":"struct 在處理 struct 與 json 資料轉換時，只要 struct 內元素的名稱字首是大寫，就可以轉換成 json struct 轉換成 json json 的 key 會跟 struct 元素名稱一樣 type Person struct { Name string Age int } func main() { p := Person{ Name: \"vito\", Age: 11, } b, err := json.Marshal(p) if err != nil { fmt.Println(\"err: \", err) } fmt.Println(string(b)) // output: {\"Name\":\"vito\",\"Age\":11} } json 轉換成 struct 沒有加 struct tag 的情況下不管大小寫，只要字母是一樣即可將 json 轉換成 struct type Person struct { Personname string Age int } func main() { j := []byte(`{ \"personName\":\"vito\", \"age\":11 }`) p := Person{} if err := json.Unmarshal(j, \u0026p); err != nil { fmt.Println(\"err: \", err) } fmt.Println(p) // output: {vito 11} } ","date":"2022-06-09","objectID":"https://xxxVitoxxx.github.io/2022/06/golang-json/:1:1","tags":["golang","json"],"title":"用 golang 處理 json 資料","uri":"https://xxxVitoxxx.github.io/2022/06/golang-json/"},{"categories":["golang"],"content":"map map 轉換成 json func main() { m := map[string]interface{}{ \"name\": \"vito\", \"age\": 11, } b, err := json.Marshal(m) if err != nil { fmt.Println(\"err: \", err) } fmt.Println(string(b)) // output: {\"age\":11,\"name\":\"vito\"} } json 轉換成 map func main() { j := []byte(`{ \"name\":\"vito\", \"age\":11 }`) var m map[string]interface{} if err := json.Unmarshal(j, \u0026m); err != nil { fmt.Println(\"err: \", err) } fmt.Println(m) // output: map[age:11 name:vito] } ","date":"2022-06-09","objectID":"https://xxxVitoxxx.github.io/2022/06/golang-json/:1:2","tags":["golang","json"],"title":"用 golang 處理 json 資料","uri":"https://xxxVitoxxx.github.io/2022/06/golang-json/"},{"categories":["golang"],"content":"struct tag 可以看到上面 struct 轉成 json 的範例，轉換後的 key 都是大寫，如果今天你想要 key 是小寫的該怎麼辦呢？golang 提供了 struct tag 來實現 type Person struct { Name string `json:\"name\"` Age int `json:\"age\"` } func main() { p := Person{ Name: \"vito\", Age: 11, } b, err := json.Marshal(p) if err != nil { fmt.Println(\"err: \", err) } fmt.Println(string(b)) // output: {\"name\":\"vito\",\"age\":11} } 也可以透過 json tag 定義 key 值 type Person struct { Name string `json:\"person_name\"` Age int `json:\"person_age\"` } func main() { p := Person{ Name: \"vito\", Age: 11, } b, err := json.Marshal(p) if err != nil { fmt.Println(\"err: \", err) } fmt.Println(string(b)) // output: {\"person_name\":\"vito\",\"person_age\":11} } ","date":"2022-06-09","objectID":"https://xxxVitoxxx.github.io/2022/06/golang-json/:2:0","tags":["golang","json"],"title":"用 golang 處理 json 資料","uri":"https://xxxVitoxxx.github.io/2022/06/golang-json/"},{"categories":["golang"],"content":"omitempty 忽略空值 當結構體元素是默認值時，想要忽略它，可以使用 omitempty type Person struct { Name string `json:\"name,omitempty\"` Age int `json:\"age,omitempty\"` Address string `json:\"address,omitempty\"` } func main() { p := Person{ Name: \"vito\", Age: 11, } b, err := json.Marshal(p) if err != nil { fmt.Println(\"err: \", err) } fmt.Println(string(b)) // {\"name\":\"vito\",\"age\":11} // 當 Address 為默認值 \"\" 時，會忽略該元素 } 忽略 struct 當想忽略 Person 中的 School 時，則 School 必須是 pointer type Person struct { Name string `json:\"name,omitempty\"` Age int `json:\"age,omitempty\"` Address string `json:\"address,omitempty\"` // 若 School 不是 pointer ，就算加 omitempty 也無法忽略它 School *School `json:\"school,omitempty\"` } type School struct { Name string `json:\"name\"` Address string `json:\"address\"` } func main() { p := Person{ Name: \"vito\", Age: 11, } b, err := json.Marshal(p) if err != nil { fmt.Println(\"err: \", err) } fmt.Println(string(b)) // {\"name\":\"vito\",\"age\":11} } ","date":"2022-06-09","objectID":"https://xxxVitoxxx.github.io/2022/06/golang-json/:2:1","tags":["golang","json"],"title":"用 golang 處理 json 資料","uri":"https://xxxVitoxxx.github.io/2022/06/golang-json/"},{"categories":["golang"],"content":"string 轉換成 json 時，將型態轉為字串 type Person struct { Name string `json:\"name\"` Age int `json:\"age,string\"` } func main() { p := Person{ Name: \"vito\", Age: 11, } b, err := json.Marshal(p) if err != nil { fmt.Println(\"err: \", err) } fmt.Println(string(b)) // age 的值被轉為文字型態 // output: {\"name\":\"vito\",\"age\":\"11\"} } json 轉換 struct 將 json 格式的 age 的值（type: string） 轉換成 struct 時，原先 age 的型態會被轉成 int type Person struct { Name string `json:\"name\"` Age int `json:\"age,string\"` } func main() { // 原始的 json 資料， age 的值是文字型態的 11 j := []byte(`{ \"name\":\"vito\", \"age\":\"11\" }`) var p Person if err := json.Unmarshal(j, \u0026p); err != nil { fmt.Println(\"err: \", err) } fmt.Println(p) // output: {vito 11} fmt.Printf(\"%T\\n\", p.Age) // 轉換成 struct 後，原先文字型態的 11 變成 int 型態的 11 // output: int } 當要轉換成 struct 時，如果型態有錯誤，會回傳錯誤訊息，但還是會成功轉換成 struct ，只是型態有問題的元素的值會是默認值，而不是你的資料 type Person struct { Name string `json:\"name\"` Age int `json:\"age,string\"` } func main() { j := []byte(`{ \"name\":\"vito\", \"age\":\"11.1\" }`) var p Person if err := json.Unmarshal(j, \u0026p); err != nil { // 預計 json age 的值會變轉成 int ，但 json age 的值轉換後是 float ，所以出現錯誤 fmt.Println(\"err: \", err) // err: json: cannot unmarshal number 11.1 into Go struct field Person.age of type int } fmt.Println(p) // output: {vito 0} } ","date":"2022-06-09","objectID":"https://xxxVitoxxx.github.io/2022/06/golang-json/:2:2","tags":["golang","json"],"title":"用 golang 處理 json 資料","uri":"https://xxxVitoxxx.github.io/2022/06/golang-json/"},{"categories":["golang"],"content":"- 不管是否有資料想忽略元素可以用 - type Person struct { Name string `json:\"name\"` Age int `json:\"-\"` } func main() { p := Person{ Name: \"vito\", Age: 11, } b, err := json.Marshal(p) if err != nil { fmt.Println(\"err: \", err) } fmt.Println(string(b)) // output: {\"name\":\"vito\"} } 若只是想讓 json 的 key 是 - 時，只需要再加上 , type Person struct { Name string `json:\"name\"` Age int `json:\"-,\"` } func main() { p := Person{ Name: \"vito\", Age: 11, } b, err := json.Marshal(p) if err != nil { fmt.Println(\"err: \", err) } fmt.Println(string(b)) // output: {\"name\":\"vito\",\"-\":11} } ","date":"2022-06-09","objectID":"https://xxxVitoxxx.github.io/2022/06/golang-json/:2:3","tags":["golang","json"],"title":"用 golang 處理 json 資料","uri":"https://xxxVitoxxx.github.io/2022/06/golang-json/"},{"categories":["heroku"],"content":"軟體 pgAdmin Heroku PostgreSQL project ","date":"2021-10-05","objectID":"https://xxxVitoxxx.github.io/2021/10/operate-heroku-pg-using-pgadmin/:1:0","tags":["heroku","postgres"],"title":"透過 pgAdmin 操作 Heroku PostgreSQL Database","uri":"https://xxxVitoxxx.github.io/2021/10/operate-heroku-pg-using-pgadmin/"},{"categories":["heroku"],"content":"建立 postgres 登入Heroku，進到有Postgre專案的Resource，點擊Heroku Postgres 點選settings，我們需要 ‘Host’、‘Database’、‘User’、‘Port’、‘Password’ 的資訊 ","date":"2021-10-05","objectID":"https://xxxVitoxxx.github.io/2021/10/operate-heroku-pg-using-pgadmin/:2:0","tags":["heroku","postgres"],"title":"透過 pgAdmin 操作 Heroku PostgreSQL Database","uri":"https://xxxVitoxxx.github.io/2021/10/operate-heroku-pg-using-pgadmin/"},{"categories":["heroku"],"content":"建立與Heroku PostgreSQL資料庫的連結設定 開啟pgAdmin，在左上角的Servers點擊右鍵 →Create →Server… 在General標簽頁中，Name 欄位輸入可識別的名稱 在Connection標簽頁中 Host name/address 對應 Heroku Postgres的Host Port 對應 Heroku Postgres的Port Maintenance database 對應 Heroku Postgres的Database Username 對應 Heroku Postgres的User Password 對應 Heroku Postgres的Password Save password 勾選起來 在SSL標簽頁中，SSLmode 選擇Allow 關於其他選項可參考文件 在Advanced標簽頁中 DB restriction對應 Heroku Postgres的Database 點擊下方 Save存儲 存儲後打開的畫面可以看到在Heroku PostgreSQL的所有資料表都在Tables標籤下 ","date":"2021-10-05","objectID":"https://xxxVitoxxx.github.io/2021/10/operate-heroku-pg-using-pgadmin/:3:0","tags":["heroku","postgres"],"title":"透過 pgAdmin 操作 Heroku PostgreSQL Database","uri":"https://xxxVitoxxx.github.io/2021/10/operate-heroku-pg-using-pgadmin/"},{"categories":["heroku"],"content":"利用SQL語法來查詢資料庫的資料 在左邊的框框點擊右鍵選擇Query Tool 輸入SQL語法點擊右上方的三角形圖案執行命令 ","date":"2021-10-05","objectID":"https://xxxVitoxxx.github.io/2021/10/operate-heroku-pg-using-pgadmin/:4:0","tags":["heroku","postgres"],"title":"透過 pgAdmin 操作 Heroku PostgreSQL Database","uri":"https://xxxVitoxxx.github.io/2021/10/operate-heroku-pg-using-pgadmin/"},{"categories":["git"],"content":"建立 ssh key 和 git clone 、 git push 教學 GitHub 提供了兩種連線方式，分別是https與ssh，兩者最大的差別在於ssh可以立刻上傳，不需要輸入密碼，且安全性高。 ","date":"2021-05-17","objectID":"https://xxxVitoxxx.github.io/2021/05/git-clone-ssh-key/:0:0","tags":["ssh key"],"title":"Git Clone With SSH Key","uri":"https://xxxVitoxxx.github.io/2021/05/git-clone-ssh-key/"},{"categories":["git"],"content":"如何透過ssh連結GitHub 第一步：依作業系統下載對應的Git(本示範系統是macos) (或透過Homebrew download: $ brew install git) 第二步：產生金鑰 $ ssh-keygen -t rsa -b 4096 -C ' your id ' 用ssh-keygen建立金鑰 系統會請你輸入通行碼(若沒輸入直接回車，之後clone就不用輸入密碼) 再輸入一次通行碼後會顯示ssh的公鑰及私鑰路徑檔名 第三步： 將id_rsa.pub(公鑰)的內容新增到GitHub的Settings的SSH keys (公鑰的內容) $ cat ./.ssh/id_rsa.pub 點擊Add就大功告成！！！ ","date":"2021-05-17","objectID":"https://xxxVitoxxx.github.io/2021/05/git-clone-ssh-key/:1:0","tags":["ssh key"],"title":"Git Clone With SSH Key","uri":"https://xxxVitoxxx.github.io/2021/05/git-clone-ssh-key/"},{"categories":["git"],"content":"clone 第一步：先在終端機進到你要建立專案的地方。 $ cd 要建立專案的地方 第二步：clone 專案到本機 $ get clone '專案ssh網址' 第三部：輸入通行碼(若當初有設定的話) 下圖表示成功將專案裡的檔案clone到主機 clone下來的資料夾名稱會是你的GitHub的repository名稱 ","date":"2021-05-17","objectID":"https://xxxVitoxxx.github.io/2021/05/git-clone-ssh-key/:2:0","tags":["ssh key"],"title":"Git Clone With SSH Key","uri":"https://xxxVitoxxx.github.io/2021/05/git-clone-ssh-key/"},{"categories":["git"],"content":"push 第一步：示範新增一個名為README.md的檔案 並將新檔案丟到專案(xxxVitoxxx.github.io)的資料夾裡，並cd到專案的資料夾 第二步：確認專案的資料夾做了哪些更動 $ git status (紅色字體代表有更改過的檔案) 第三步：將新增的檔案加到Git版本控管 $ git add . (注意！！！這邊只是將專案資料夾的所有檔案加到Git工作目錄的索引中，尚未加到Git版本庫)。 可以再輸入一次 $ git status 確認專案資料夾的檔案是否已成功更新(綠色字體代表成功更新檔案) 第四步：為修改記錄命名一個名稱 $ git commit -m \"commit message\" 這邊將第一次修改記錄命名為’first commit' $ git log 可以查看該專案的修改紀錄 第五步： $ git push 將剛剛新增的檔案推到GitHub上 ","date":"2021-05-17","objectID":"https://xxxVitoxxx.github.io/2021/05/git-clone-ssh-key/:3:0","tags":["ssh key"],"title":"Git Clone With SSH Key","uri":"https://xxxVitoxxx.github.io/2021/05/git-clone-ssh-key/"},{"categories":null,"content":"About","date":"2019-08-02","objectID":"https://xxxVitoxxx.github.io/about/","tags":null,"title":"About","uri":"https://xxxVitoxxx.github.io/about/"}]